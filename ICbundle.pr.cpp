/* Process model C++ form file: ICbundle.pr.cpp */
/* Portions of this file copyright 1986-2012 by OPNET Technologies, Inc. */


/*
 =========================== NOTE ==========================
 This file is automatically generated from ICbundle.pr.m
 during a process model compilation.

 Do NOT manually edit this file.
 Manual edits will be lost during the next compilation.
 =========================== NOTE ==========================
*/



/* This variable carries the header into the object file */
const char ICbundle_pr_cpp [] = "MIL_3_Tfile_Hdr_ 171A 30A modeler 7 57E8300B 57E8300B 1 JinzeYANG-PC Jinze@YANG 0 0 none none 0 0 none 0 0 0 0 0 0 0 0 2b74 2                                                                                                                                                                                                                                                                                                                                                                                                  ";
#include <string.h>



/* OPNET system definitions */
#include <opnet.h>



/* Header Block */

#include <opnet.h>
#include <string.h>
#include <stdlib.h>
#include <assert.h>
#include <stdio.h>

//hello related
#define IP_BROADCAST_ADDR	-1
#define HELLO_INTERVAL 		0.2
#define ALLOW_LOSS			2

/*define data types*/
#define DATA_APP_SM 1
#define DATA_APP_BG 2
#define DATA_APP_BE 3
#define DATA_APP_INT 4
#define DATA_APP_CON 5


/*define intrpt codes*/
#define DATA_APP_SM_CODE 1
#define DATA_APP_BG_CODE 2
#define DATA_APP_BE_CODE 3

/*define the index of input stream and output stream*/
#define UPP_INPUT_STRM		1
#define UPP_OUTPUT_STRM		1
#define LOW_INPUT_STRM		0
#define LOW_OUTPUT_STRM		0

//intrpt code OLD
#define END_PNT_CODE		1
#define FORWARD_CODE		2
#define SRC_RETRANS_CODE		3
#define CUST_RETRANS_CODE		4
//intrpt code NEW
#define HELLO_INTRPT_CODE		5
#define RETRI_FORWARD_CODE		6
#define RETRI_STORAGE_CODE		7
#define	RETRI_INTEREST_CODE		8

//pkt type
#define BUNDLE_TYPE			20 
#define ADMIN_TYPE			21
#define CUST_SIG_TYPE		22
#define HELLO_TYPE			23
#define CONTENT				24
#define REQ					25

//proc flag bit mask
#define RECEPTION_F			0x01
#define CUST_ACCEP_F		0X02
#define FORWARD_F			0x04
#define DELIVERY_F			0x08
#define CUST_REQ_F			0x10

/*define the transation conditions*/
#define DATA_FROM_APP   (OPC_INTRPT_STRM== intrpt_type && intrpt_stream == UPP_INPUT_STRM)
#define DATA_FROM_IP  	(OPC_INTRPT_STRM== intrpt_type && intrpt_stream == LOW_INPUT_STRM)
#define HELLO_INTRPT 	(OPC_INTRPT_SELF== intrpt_type && intrpt_code == HELLO_INTRPT_CODE)
#define RETRI_FORWARD 	(OPC_INTRPT_SELF== intrpt_type && intrpt_code == RETRI_FORWARD_CODE)
#define RETRI_STORAGE 	(OPC_INTRPT_SELF== intrpt_type && intrpt_code == RETRI_STORAGE_CODE)
#define RETRI_INTEREST 	(OPC_INTRPT_SELF== intrpt_type && intrpt_code == RETRI_INTEREST_CODE)
#define END_SIM		 	(OPC_INTRPT_SELF== intrpt_type && intrpt_code == OPC_INTRPT_SCHED_CALL_ENDSIM)

typedef struct Neighbor_t{
	int 		addr;
	int			last_seq;
	int 		first_seq;
	Evhandle 	expire;

}Neighbor_t;



//-----seq
int 		icdtn_get_ip_address_from_name(char* node_name);
//int			bp_seq_compare (const Send_table *t1, const Send_table *t2);
//int			bp_list_search(int seq, List* l);
//Boolean		bp_list_item_remove(int seq, List* l);

int			icdtn_hello_handle (Packet* p_bundle);


//int 		bp_flag_generate();
//void 		bp_bundle_retrans(Send_table* send_t, int code);


//Packet* 	bp_status_report_generate(int flag, double creat_time, int seq, int src);
//Packet* 	bp_custody_signal_generate(Boolean succ, double creat_time, int seq, int src);
//Packet* 	bp_primary_generate(int type, int dest,int pkt_id, int flag, Packet* payload, Send_table* send_t);

//call back function
void icdtn_neighbor_t_delete_cb(Neighbor_t* nt, int code);
void icdtn_sim_end_cb(void* ptr, int code);

/* End of Header Block */

#if !defined (VOSD_NO_FIN)
#undef	BIN
#undef	BOUT
#define	BIN		FIN_LOCAL_FIELD(_op_last_line_passed) = __LINE__ - _op_block_origin;
#define	BOUT	BIN
#define	BINIT	FIN_LOCAL_FIELD(_op_last_line_passed) = 0; _op_block_origin = __LINE__;
#else
#define	BINIT
#endif /* #if !defined (VOSD_NO_FIN) */



/* State variable definitions */
class ICbundle_state
	{
	private:
		/* Internal state tracking for FSM */
		FSM_SYS_STATE

	public:
		ICbundle_state (void);

		/* Destructor contains Termination Block */
		~ICbundle_state (void);

		/* State Variables */
		Objid	                  		my_objid                                        ;	/* the processor id  */
		Objid	                  		my_node_id                                      ;	/* the node id  */
		char	                   		name[32]                                        ;	/*  the node name  */
		int	                    		self_ip_addr                                    ;
		List*                   		FIB_list                                        ;
		List*	                  		CS_list                                         ;
		List*	                  		PIT_list                                        ;
		double	                 		retrans_time                                    ;
		double	                 		expire_time                                     ;
		int	                    		cache_max_size                                  ;
		int	                    		content_seq                                     ;
		List*	                  		neighbor_l                                      ;
		int	                    		hello_seq                                       ;

		/* FSM code */
		void ICbundle (OP_SIM_CONTEXT_ARG_OPT);
		/* Diagnostic Block */
		void _op_ICbundle_diag (OP_SIM_CONTEXT_ARG_OPT);

#if defined (VOSD_NEW_BAD_ALLOC)
		void * operator new (size_t) throw (VOSD_BAD_ALLOC);
#else
		void * operator new (size_t);
#endif
		void operator delete (void *);

		/* Memory management */
		static VosT_Obtype obtype;
	};

VosT_Obtype ICbundle_state::obtype = (VosT_Obtype)OPC_NIL;

#define my_objid                		op_sv_ptr->my_objid
#define my_node_id              		op_sv_ptr->my_node_id
#define name                    		op_sv_ptr->name
#define self_ip_addr            		op_sv_ptr->self_ip_addr
#define FIB_list                		op_sv_ptr->FIB_list
#define CS_list                 		op_sv_ptr->CS_list
#define PIT_list                		op_sv_ptr->PIT_list
#define retrans_time            		op_sv_ptr->retrans_time
#define expire_time             		op_sv_ptr->expire_time
#define cache_max_size          		op_sv_ptr->cache_max_size
#define content_seq             		op_sv_ptr->content_seq
#define neighbor_l              		op_sv_ptr->neighbor_l
#define hello_seq               		op_sv_ptr->hello_seq

/* These macro definitions will define a local variable called	*/
/* "op_sv_ptr" in each function containing a FIN statement.	*/
/* This variable points to the state variable data structure,	*/
/* and can be used from a C debugger to display their values.	*/
#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE
#define FIN_PREAMBLE_DEC	ICbundle_state *op_sv_ptr;
#define FIN_PREAMBLE_CODE	\
		op_sv_ptr = ((ICbundle_state *)(OP_SIM_CONTEXT_PTR->_op_mod_state_ptr));


/* Function Block */

#if !defined (VOSD_NO_FIN)
enum { _op_block_origin = __LINE__ + 2};
#endif

int icdtn_get_ip_address_from_name(char* node_name)
	{
		int i;
		int j;
		char id_str[8];
		int ip_address;
		FIN(get_ip_address_from_name_mac(char* node_name));
		i=5;
		j=0;
		while(*(node_name+i) != '\0')
			{
				id_str[j] = *(node_name+i);
				i++;
				j++;
			}
		id_str[j] = '\0';
		ip_address = atoi(id_str);
		FRET(ip_address);
	}
/*
int bp_seq_compare (const Send_table *t1, const Send_table *t2){
   FIN (bp_seq_compare (Send_table *t1, Send_table *t2));

   if ( (t1->seq_n) < (t2->seq_n) ){
      FRET (1);
	}
   else if ( (t1->seq_n) < (t2->seq_n) ){
      FRET (-1);
	}
   else{
      FRET (0);
	}
}

int bp_flag_generate(){

	FIN (bp_flag generate());
	
	//printf("flag generate\n");
	int flag = 0x00;
	
	if (recv_f == OPC_TRUE){
		flag = flag | RECEPTION_F;
	}
	if (cust_acc_f == OPC_TRUE){
		flag = flag | CUST_ACCEP_F;
	}
	if (forward_f == OPC_TRUE){
		flag = flag | FORWARD_F;
	}
	if (deliver_f == OPC_TRUE){
		flag = flag | DELIVERY_F;
	}
	if (cust_req_f == OPC_TRUE){
		flag = flag | CUST_REQ_F;
	}

	FRET (flag);
}

void bp_bundle_retrans(Send_table* send_t, int code){
	FIN (bp_bundle_retrans(Send_table* send_t, int code));
	
	List* l;
	int pos;
	
	if (cust_f == OPC_TRUE && send_t->cust_acc == OPC_TRUE )
		op_sim_end("unexpected bundle retrans","","","");
	if (code == SRC_RETRANS_CODE)
		l = send_list;
	else
		l = cust_list;
	if (send_t->create_time + expire_time < op_sim_time()){
		//op_sim_end();
		//
		pos = bp_list_search(send_t->seq_n,l);
		op_prg_list_remove(l, pos);
	}
	else{
		send_t->expired_handle = op_intrpt_schedule_call (op_sim_time()+retrans_time, code, bp_bundle_retrans,send_t);
		send_t->retrans_n++;
		op_pk_send (op_pk_copy(send_t->bundle),LOW_OUTPUT_STRM);
	}
	
	FOUT;
}

//the return value is the index of the t, if the t dosen't found, this function 
// will return -1
int bp_list_search(int seq, List* l){
	FIN (bp_list_search(int seq, List* l));
	
	int size = op_prg_list_size(l);
	int i = 0;
	
	for (i=0; i< size && size >0 ; i++){
		Send_table* temp = op_prg_list_access(l,i);
		printf("\nseq=%d retrans_n=%d-------",temp->seq_n,temp->retrans_n);
		if (temp->seq_n == seq)
			FRET (i);
	}
	FRET (-1);
}

Boolean bp_list_item_remove(int seq, List* l){
	FIN(bp_list_item_remove(int seq, List* l));
	
	int pos = bp_list_search(seq,l);
	printf("node %d bundle %d release\n",self_ip_addr,seq);
	if (pos >= 0 && pos < op_prg_list_size(l)){
		Send_table* t = op_prg_list_remove(l, pos);
		op_pk_destroy(t->bundle);
		op_ev_cancel_if_pending(t->expired_handle);
		op_prg_mem_free(t);
	}
	else{
		FRET (OPC_FALSE);
	}
	
	FRET (OPC_TRUE);
}

Packet* bp_status_report_generate(int flag, double creat_time, int seq, int src){
	FIN (bp_status_report_generate(int flag, double creat_time, int seq, int src));
	
	Packet* admin = op_pk_create_fmt("bundle status report");
	
	if (flag == 0){
		FRET (OPC_NIL);
	}
	
	if ( (flag&RECEPTION_F) == RECEPTION_F){
		op_pk_nfd_set(admin, "receipt time", op_sim_time());
	}
	if ((flag&CUST_ACCEP_F) == CUST_ACCEP_F){
		op_pk_nfd_set(admin, "cust accept time", op_sim_time());
	}
	if ( (flag&FORWARD_F) == FORWARD_F ){
		op_pk_nfd_set(admin, "foward time", op_sim_time());
	}
	if ( (flag&DELIVERY_F) == DELIVERY_F){
		op_pk_nfd_set(admin, "delivery time", op_sim_time());
	}
	//if ( (flag&SUCCESS_F) == SUCCESS_F ){
	//	op_pk_nfd_set(admin, "receipt time", op_sim_time());
	//}
	
		
	op_pk_nfd_set(admin, "status flag", flag);
	op_pk_nfd_set(admin, "creat time", creat_time);
	op_pk_nfd_set(admin, "seq", seq);
	op_pk_nfd_set(admin, "src", src);

	
	FRET (admin);
}

Packet* bp_custody_signal_generate(Boolean succ, double creat_time, int seq, int src){
	FIN (bp_status_report_generate(Boolean succ, double creat_time, int seq, int src));
	Packet* admin = op_pk_create_fmt("bundle custody signal");
	
	if (succ == OPC_TRUE){
		op_pk_nfd_set(admin, "status flag", OPC_TRUE);
	}
	else{
		op_pk_nfd_set(admin, "status flag", OPC_FALSE);
	}
	op_pk_nfd_set(admin, "time of sig", op_sim_time());
	op_pk_nfd_set(admin, "bundle create time", creat_time);
	op_pk_nfd_set(admin, "bundle seq", seq);
	op_pk_nfd_set(admin, "src", src);
	
	FRET (admin);
}

Packet* bp_primary_generate(int type, int dest,int pkt_id, int flag, Packet* payload, Send_table* send_t){
	FIN (bp_primary_generate(int type, int dest,int pkt_id, int flag, Packet* payload, Send_table* send_t));
	
	Packet* p_bundle = op_pk_create_fmt("primary bundle block");
	
	op_pk_nfd_set (p_bundle, "type", type);
	op_pk_nfd_set (p_bundle, "dest", dest);
	op_pk_nfd_set (p_bundle, "pkt_id", pkt_id);
	op_pk_nfd_set (p_bundle, "proc flag", flag);
	op_pk_nfd_set (p_bundle, "des ssp offset", dest);
	op_pk_nfd_set (p_bundle, "src ssp offset", self_ip_addr);
	op_pk_nfd_set (p_bundle, "report ssp offset", self_ip_addr);
	op_pk_nfd_set (p_bundle, "cust ssp offset", self_ip_addr);
	op_pk_nfd_set (p_bundle, "creat time", op_sim_time());
	op_pk_nfd_set (p_bundle, "seq", pkt_id);
	op_pk_nfd_set (p_bundle, "life time", expire_time);
	op_pk_nfd_set_pkt (p_bundle, "payload", payload);
	
	//send_t = op_prg_mem_alloc (sizeof (Send_table));
	send_t->src = self_ip_addr;
	send_t->des = dest;
	send_t->seq_n = pkt_id;
	
	send_t->retrans_n = 0;
	send_t->create_time = op_sim_time();
	//send_t->expired_handle = op_intrpt_schedule_call (op_sim_time()+retrans_time, RETRANS_CODE, bp_bundle_retrans,send_t);
	send_t->bundle = p_bundle;
	
	send_t->send_f = OPC_TRUE;
	send_t->reception = OPC_FALSE;	//get reception of not
	send_t->cust_acc  = OPC_FALSE;	//custody accepted or not
	send_t->delivery  = OPC_FALSE;
	
	FRET (p_bundle);
}
*/
int	icdtn_hello_handle(Packet* p_bundle){
	FIN (icdtn_hello_handle);
	int i;
	int l_size;
	int src;
	int type;
	//int dest;
	int seq_no;
	Neighbor_t* nt;

	
	op_pk_nfd_access (p_bundle,"type",&type);
	op_pk_nfd_access (p_bundle,"src",&src);
	//op_pk_nfd_access (p_bundle,"dest",IP_BROADCAST_ADDR);//yang 2.1
	op_pk_nfd_access (p_bundle,"seq_no",&seq_no);
	
	l_size = op_prg_list_size(neighbor_l);
	for (i = 0; i < l_size; i++){
		nt = (Neighbor_t*)op_prg_list_access(neighbor_l, i);
		if (nt->addr == src && nt->last_seq < seq_no  ){
			//printf("node %d get hello from %d\n",self_ip_addr,src);	
			nt->last_seq = seq_no;
			op_ev_cancel_if_pending( nt-> expire );
			nt-> expire = op_intrpt_schedule_call(op_sim_time()+HELLO_INTERVAL*ALLOW_LOSS, 
				0, icdtn_neighbor_t_delete_cb, nt);
			break;
		}
	}
	if (i == l_size){
		//printf("%d create a new neighbor t for %d\n",self_ip_addr, src);
		nt = op_prg_mem_alloc (sizeof (Neighbor_t) );
		nt-> addr = src;
		nt-> last_seq = seq_no;
		nt-> first_seq = seq_no;
		nt-> expire = op_intrpt_schedule_call(op_sim_time()+HELLO_INTERVAL*ALLOW_LOSS, 
			0, icdtn_neighbor_t_delete_cb, nt);
		op_prg_list_insert (neighbor_l, nt, OPC_LISTPOS_HEAD);
	}
	
	FRET (0);
}

void icdtn_neighbor_t_delete_cb(Neighbor_t* nt, int code){
	FIN (icdtn_neighbor_t_delete_cb);

	int i = 0;
	int l_size = op_prg_list_size(neighbor_l);
	double hello_count = 0;
	Neighbor_t* nt_temp;
	
	for (i = 0; i < l_size; i++){
		nt_temp = (Neighbor_t*)op_prg_list_access(neighbor_l, i);
		if ( nt->addr == nt_temp->addr  ){
			nt_temp = (Neighbor_t*)op_prg_list_remove(neighbor_l, i);
			
			hello_count = (double)(nt_temp->last_seq - nt_temp->first_seq + 1);
			op_stat_scalar_write ("link time - self addr", self_ip_addr);
			op_stat_scalar_write ("link time - neighbor addr", nt_temp-> addr);
			op_stat_scalar_write ("link time - link time", hello_count*HELLO_INTERVAL);
			
			op_ev_cancel_if_pending( nt_temp-> expire ); 
			op_prg_mem_free(nt_temp);
			
			break;
		}
		
	}
	if (i == l_size){
		op_sim_end("neighbor_t delete error","","","");
	}
			

	FOUT;
}

void icdtn_sim_end_cb(void* ptr, int code){
	FIN (icdtn_sim_end_cb)
		
	int i = 0;
	int l_size = op_prg_list_size(neighbor_l);
	double hello_count = 0;
	Neighbor_t* nt_temp;
	
	printf("end of sim! list size = %d\n",l_size);
	for (i = 0; i < l_size; i++){
		nt_temp = (Neighbor_t*)op_prg_list_access(neighbor_l, i);
			
		hello_count = (double)(nt_temp->last_seq - nt_temp->first_seq + 1);
		op_stat_scalar_write ("link time - self addr", self_ip_addr);
		op_stat_scalar_write ("link time - neighbor addr", nt_temp-> addr);
		op_stat_scalar_write ("link time - link time", hello_count*HELLO_INTERVAL);
	}
	
	FOUT

}

/* End of Function Block */

/* Undefine optional tracing in FIN/FOUT/FRET */
/* The FSM has its own tracing code and the other */
/* functions should not have any tracing.		  */
#undef FIN_TRACING
#define FIN_TRACING

#undef FOUTRET_TRACING
#define FOUTRET_TRACING

/* Undefine shortcuts to state variables because the */
/* following functions are part of the state class */
#undef my_objid
#undef my_node_id
#undef name
#undef self_ip_addr
#undef FIB_list
#undef CS_list
#undef PIT_list
#undef retrans_time
#undef expire_time
#undef cache_max_size
#undef content_seq
#undef neighbor_l
#undef hello_seq

/* Access from C kernel using C linkage */
extern "C"
{
	VosT_Obtype _op_ICbundle_init (int * init_block_ptr);
	VosT_Address _op_ICbundle_alloc (VosT_Obtype, int);
	void ICbundle (OP_SIM_CONTEXT_ARG_OPT)
		{
		((ICbundle_state *)(OP_SIM_CONTEXT_PTR->_op_mod_state_ptr))->ICbundle (OP_SIM_CONTEXT_PTR_OPT);
		}

	void _op_ICbundle_svar (void *, const char *, void **);

	void _op_ICbundle_diag (OP_SIM_CONTEXT_ARG_OPT)
		{
		((ICbundle_state *)(OP_SIM_CONTEXT_PTR->_op_mod_state_ptr))->_op_ICbundle_diag (OP_SIM_CONTEXT_PTR_OPT);
		}

	void _op_ICbundle_terminate (OP_SIM_CONTEXT_ARG_OPT)
		{
		/* The destructor is the Termination Block */
		delete (ICbundle_state *)(OP_SIM_CONTEXT_PTR->_op_mod_state_ptr);
		}


} /* end of 'extern "C"' */




/* Process model interrupt handling procedure */


void
ICbundle_state::ICbundle (OP_SIM_CONTEXT_ARG_OPT)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	FIN_MT (ICbundle_state::ICbundle ());
	try
		{
		/* Temporary Variables */
		
		// get interupt type 
		int intrpt_type; 
		int intrpt_stream;
		int intrpt_code;
		
		//int dest, type;
		
		//Packet* app_pkt;
		Packet* p_bundle;
		
		/* End of Temporary Variables */


		FSM_ENTER ("ICbundle")

		FSM_BLOCK_SWITCH
			{
			/*---------------------------------------------------------*/
			/** state (init) enter executives **/
			FSM_STATE_ENTER_FORCED_NOLABEL (0, "init", "ICbundle [init enter execs]")
				FSM_PROFILE_SECTION_IN ("ICbundle [init enter execs]", state0_enter_exec)
				{
				my_objid = op_id_self ();
				my_node_id = op_topo_parent (my_objid);
				op_ima_obj_attr_get (my_node_id, "name", &name);
				self_ip_addr = icdtn_get_ip_address_from_name(name);
				
				//state variable
				neighbor_l = op_prg_list_create();
				hello_seq = 0; 
				
				//schedule
				op_intrpt_schedule_call (OPC_INTRPT_SCHED_CALL_ENDSIM,0,icdtn_sim_end_cb,OPC_NIL);
				
				//printf("prepare send hello\n");
				op_intrpt_schedule_self (op_sim_time(), HELLO_INTRPT_CODE);
				
				//op_sim_end("ini finish","","","");
				}
				FSM_PROFILE_SECTION_OUT (state0_enter_exec)

			/** state (init) exit executives **/
			FSM_STATE_EXIT_FORCED (0, "init", "ICbundle [init exit execs]")


			/** state (init) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "init", "idle", "tr_0", "ICbundle [init -> idle : default / ]")
				/*---------------------------------------------------------*/



			/** state (idle) enter executives **/
			FSM_STATE_ENTER_UNFORCED (1, "idle", state1_enter_exec, "ICbundle [idle enter execs]")

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (3,"ICbundle")


			/** state (idle) exit executives **/
			FSM_STATE_EXIT_UNFORCED (1, "idle", "ICbundle [idle exit execs]")
				FSM_PROFILE_SECTION_IN ("ICbundle [idle exit execs]", state1_exit_exec)
				{
				intrpt_type=op_intrpt_type();
				
				if(intrpt_type == OPC_INTRPT_STRM){
					intrpt_stream = op_intrpt_strm();
				}
				else if (intrpt_type == OPC_INTRPT_SELF){
					intrpt_code = op_intrpt_code();
					
				}
				
				
				
				}
				FSM_PROFILE_SECTION_OUT (state1_exit_exec)


			/** state (idle) transition processing **/
			FSM_PROFILE_SECTION_IN ("ICbundle [idle trans conditions]", state1_trans_conds)
			FSM_INIT_COND (DATA_FROM_APP)
			FSM_TEST_COND (DATA_FROM_IP)
			FSM_TEST_COND (HELLO_INTRPT)
			FSM_TEST_COND (RETRI_FORWARD)
			FSM_TEST_COND (RETRI_STORAGE)
			FSM_TEST_COND (RETRI_INTEREST)
			FSM_DFLT_COND
			FSM_TEST_LOGIC ("idle")
			FSM_PROFILE_SECTION_OUT (state1_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 2, state2_enter_exec, ;, "DATA_FROM_APP", "", "idle", "DATA_FROM_APP", "tr_2", "ICbundle [idle -> DATA_FROM_APP : DATA_FROM_APP / ]")
				FSM_CASE_TRANSIT (1, 3, state3_enter_exec, ;, "DATA_FROM_IP", "", "idle", "DATA_FROM_IP", "tr_3", "ICbundle [idle -> DATA_FROM_IP : DATA_FROM_IP / ]")
				FSM_CASE_TRANSIT (2, 4, state4_enter_exec, ;, "HELLO_INTRPT", "", "idle", "register", "tr_5", "ICbundle [idle -> register : HELLO_INTRPT / ]")
				FSM_CASE_TRANSIT (3, 5, state5_enter_exec, ;, "RETRI_FORWARD", "", "idle", "FIB", "tr_7", "ICbundle [idle -> FIB : RETRI_FORWARD / ]")
				FSM_CASE_TRANSIT (4, 6, state6_enter_exec, ;, "RETRI_STORAGE", "", "idle", "CS", "tr_9", "ICbundle [idle -> CS : RETRI_STORAGE / ]")
				FSM_CASE_TRANSIT (5, 7, state7_enter_exec, ;, "RETRI_INTEREST", "", "idle", "PIT", "tr_11", "ICbundle [idle -> PIT : RETRI_INTEREST / ]")
				FSM_CASE_TRANSIT (6, 1, state1_enter_exec, ;, "default", "", "idle", "idle", "tr_14", "ICbundle [idle -> idle : default / ]")
				}
				/*---------------------------------------------------------*/



			/** state (DATA_FROM_APP) enter executives **/
			FSM_STATE_ENTER_FORCED (2, "DATA_FROM_APP", state2_enter_exec, "ICbundle [DATA_FROM_APP enter execs]")

			/** state (DATA_FROM_APP) exit executives **/
			FSM_STATE_EXIT_FORCED (2, "DATA_FROM_APP", "ICbundle [DATA_FROM_APP exit execs]")


			/** state (DATA_FROM_APP) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "DATA_FROM_APP", "idle", "tr_1", "ICbundle [DATA_FROM_APP -> idle : default / ]")
				/*---------------------------------------------------------*/



			/** state (DATA_FROM_IP) enter executives **/
			FSM_STATE_ENTER_FORCED (3, "DATA_FROM_IP", state3_enter_exec, "ICbundle [DATA_FROM_IP enter execs]")
				FSM_PROFILE_SECTION_IN ("ICbundle [DATA_FROM_IP enter execs]", state3_enter_exec)
				{
				p_bundle = op_pk_get(LOW_INPUT_STRM);
				//op_pk_print(p_bundle);
				icdtn_hello_handle(p_bundle);
				}
				FSM_PROFILE_SECTION_OUT (state3_enter_exec)

			/** state (DATA_FROM_IP) exit executives **/
			FSM_STATE_EXIT_FORCED (3, "DATA_FROM_IP", "ICbundle [DATA_FROM_IP exit execs]")


			/** state (DATA_FROM_IP) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "DATA_FROM_IP", "idle", "tr_4", "ICbundle [DATA_FROM_IP -> idle : default / ]")
				/*---------------------------------------------------------*/



			/** state (register) enter executives **/
			FSM_STATE_ENTER_FORCED (4, "register", state4_enter_exec, "ICbundle [register enter execs]")
				FSM_PROFILE_SECTION_IN ("ICbundle [register enter execs]", state4_enter_exec)
				{
				Packet* hello_pkt = op_pk_create_fmt("ICN_hello");
				op_pk_nfd_set (hello_pkt,"type",HELLO_TYPE);
				op_pk_nfd_set (hello_pkt,"src",self_ip_addr);
				op_pk_nfd_set (hello_pkt,"dest",IP_BROADCAST_ADDR);//yang 2.1
				op_pk_nfd_set (hello_pkt,"seq_no",hello_seq);
				//op_pk_print (hello_pkt);
				
				hello_seq++;
				
				op_pk_send(hello_pkt, LOW_OUTPUT_STRM);
				
				op_intrpt_schedule_self (op_sim_time() + HELLO_INTERVAL +op_dist_uniform(0.1), HELLO_INTRPT_CODE);
				}
				FSM_PROFILE_SECTION_OUT (state4_enter_exec)

			/** state (register) exit executives **/
			FSM_STATE_EXIT_FORCED (4, "register", "ICbundle [register exit execs]")


			/** state (register) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "register", "idle", "tr_6", "ICbundle [register -> idle : default / ]")
				/*---------------------------------------------------------*/



			/** state (FIB) enter executives **/
			FSM_STATE_ENTER_FORCED (5, "FIB", state5_enter_exec, "ICbundle [FIB enter execs]")

			/** state (FIB) exit executives **/
			FSM_STATE_EXIT_FORCED (5, "FIB", "ICbundle [FIB exit execs]")


			/** state (FIB) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "FIB", "idle", "tr_8", "ICbundle [FIB -> idle : default / ]")
				/*---------------------------------------------------------*/



			/** state (CS) enter executives **/
			FSM_STATE_ENTER_FORCED (6, "CS", state6_enter_exec, "ICbundle [CS enter execs]")

			/** state (CS) exit executives **/
			FSM_STATE_EXIT_FORCED (6, "CS", "ICbundle [CS exit execs]")


			/** state (CS) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "CS", "idle", "tr_10", "ICbundle [CS -> idle : default / ]")
				/*---------------------------------------------------------*/



			/** state (PIT) enter executives **/
			FSM_STATE_ENTER_FORCED (7, "PIT", state7_enter_exec, "ICbundle [PIT enter execs]")

			/** state (PIT) exit executives **/
			FSM_STATE_EXIT_FORCED (7, "PIT", "ICbundle [PIT exit execs]")


			/** state (PIT) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "PIT", "idle", "tr_12", "ICbundle [PIT -> idle : default / ]")
				/*---------------------------------------------------------*/



			}


		FSM_EXIT (0,"ICbundle")
		}
	catch (...)
		{
		Vos_Error_Print (VOSC_ERROR_ABORT,
			(const char *)VOSC_NIL,
			"Unhandled C++ exception in process model (ICbundle)",
			(const char *)VOSC_NIL, (const char *)VOSC_NIL);
		}
	}




void
ICbundle_state::_op_ICbundle_diag (OP_SIM_CONTEXT_ARG_OPT)
	{
	/* No Diagnostic Block */
	}

void
ICbundle_state::operator delete (void* ptr)
	{
	FIN (ICbundle_state::operator delete (ptr));
	Vos_Poolmem_Dealloc (ptr);
	FOUT
	}

ICbundle_state::~ICbundle_state (void)
	{

	FIN (ICbundle_state::~ICbundle_state ())


	/* No Termination Block */


	FOUT
	}


#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE

#define FIN_PREAMBLE_DEC
#define FIN_PREAMBLE_CODE

void *
ICbundle_state::operator new (size_t)
#if defined (VOSD_NEW_BAD_ALLOC)
		throw (VOSD_BAD_ALLOC)
#endif
	{
	void * new_ptr;

	FIN_MT (ICbundle_state::operator new ());

	new_ptr = Vos_Alloc_Object (ICbundle_state::obtype);
#if defined (VOSD_NEW_BAD_ALLOC)
	if (new_ptr == VOSC_NIL) throw VOSD_BAD_ALLOC();
#endif
	FRET (new_ptr)
	}

/* State constructor initializes FSM handling */
/* by setting the initial state to the first */
/* block of code to enter. */

ICbundle_state::ICbundle_state (void) :
		_op_current_block (0)
	{
#if defined (OPD_ALLOW_ODB)
		_op_current_state = "ICbundle [init enter execs]";
#endif
	}

VosT_Obtype
_op_ICbundle_init (int * init_block_ptr)
	{
	FIN_MT (_op_ICbundle_init (init_block_ptr))

	ICbundle_state::obtype = Vos_Define_Object_Prstate ("proc state vars (ICbundle)",
		sizeof (ICbundle_state));
	*init_block_ptr = 0;

	FRET (ICbundle_state::obtype)
	}

VosT_Address
_op_ICbundle_alloc (VosT_Obtype, int)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	ICbundle_state * ptr;
	FIN_MT (_op_ICbundle_alloc ())

	/* New instance will have FSM handling initialized */
#if defined (VOSD_NEW_BAD_ALLOC)
	try {
		ptr = new ICbundle_state;
	} catch (const VOSD_BAD_ALLOC &) {
		ptr = VOSC_NIL;
	}
#else
	ptr = new ICbundle_state;
#endif
	FRET ((VosT_Address)ptr)
	}



void
_op_ICbundle_svar (void * gen_ptr, const char * var_name, void ** var_p_ptr)
	{
	ICbundle_state		*prs_ptr;

	FIN_MT (_op_ICbundle_svar (gen_ptr, var_name, var_p_ptr))

	if (var_name == OPC_NIL)
		{
		*var_p_ptr = (void *)OPC_NIL;
		FOUT
		}
	prs_ptr = (ICbundle_state *)gen_ptr;

	if (strcmp ("my_objid" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->my_objid);
		FOUT
		}
	if (strcmp ("my_node_id" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->my_node_id);
		FOUT
		}
	if (strcmp ("name" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->name);
		FOUT
		}
	if (strcmp ("self_ip_addr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->self_ip_addr);
		FOUT
		}
	if (strcmp ("FIB_list" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->FIB_list);
		FOUT
		}
	if (strcmp ("CS_list" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->CS_list);
		FOUT
		}
	if (strcmp ("PIT_list" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->PIT_list);
		FOUT
		}
	if (strcmp ("retrans_time" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->retrans_time);
		FOUT
		}
	if (strcmp ("expire_time" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->expire_time);
		FOUT
		}
	if (strcmp ("cache_max_size" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->cache_max_size);
		FOUT
		}
	if (strcmp ("content_seq" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->content_seq);
		FOUT
		}
	if (strcmp ("neighbor_l" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->neighbor_l);
		FOUT
		}
	if (strcmp ("hello_seq" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->hello_seq);
		FOUT
		}
	*var_p_ptr = (void *)OPC_NIL;

	FOUT
	}

