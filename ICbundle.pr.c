/* Process model C form file: ICbundle.pr.c */
/* Portions of this file copyright 2016 by Riverbed Technology. All rights reserved. */


/*
 =========================== NOTE ==========================
 This file is automatically generated from ICbundle.pr.m
 during a process model compilation.

 Do NOT manually edit this file.
 Manual edits will be lost during the next compilation.
 =========================== NOTE ==========================
*/



/* This variable carries the header into the object file */
const char ICbundle_pr_c [] = "MIL_3_Tfile_Hdr_ 1860 30A modeler 7 5DC2F3BA 5DC2F3BA 1 DESKTOP-KBNU598 opnet 0 0 none none 0 0 none 0 0 0 0 0 0 0 0 4a68 0                                                                                                                                                                                                                                                                                                                                                                                                    ";
#include <string.h>



/* OPNET system definitions */
#include <opnet.h>



/* Header Block */

#include <opnet.h>
#include <string.h>
#include <stdlib.h>
#include <assert.h>
#include <stdio.h>
#include <prg_bin_hash.h>

//hello related
#define IP_BROADCAST_ADDR	-1
#define HELLO_INTERVAL 		hello_interval
//0.2
#define ALLOW_LOSS			allow_loss
//2

//define data types
//app
#define DATA_APP_SM 	1
#define DATA_APP_BG 	2
#define DATA_APP_BE 	3
//ccn
#define DATA_APP_INT 	10
#define DATA_APP_CON 	11


//define app intrpt codes
#define DATA_APP_SM_CODE 	1
#define DATA_APP_BG_CODE 	2
#define DATA_APP_BE_CODE 	3

//define the index of input stream and output stream
#define UPP_INPUT_STRM		1
#define UPP_OUTPUT_STRM		1
#define LOW_INPUT_STRM		0
#define LOW_OUTPUT_STRM		0

//intrpt code OLD
#define END_PNT_CODE			1
#define FORWARD_CODE			2
#define SRC_RETRANS_CODE		3
#define CUST_RETRANS_CODE		4
//intrpt code NEW
#define HELLO_INTRPT_CODE		5
#define REQ_HANDLE_CODE			6
#define DATA_HANDLE_CODE		7

//pkt type
#define BUNDLE_TYPE			20 
#define ADMIN_TYPE			21
#define CUST_SIG_TYPE		22
#define HELLO_TYPE			23
#define CONTENT_TYPE		24
#define REQ_TYPE			25

//expire time
#define FIB_EXPIR_TIME		fib_expir_time
//300
#define PIT_EXPIR_TIME		pit_expir_time
//300
#define CS_EXPIR_TIME		cs_expir_time
//6000
//CS SPACE 
//20MB
#define CS_TOTAL_SPACE		cs_total_space
//160000000
//CS SIZE
#define CS_TOTAL_SIZE		cs_total_size
//20
//
#define HOP_LIMIT			hop_lim
//10
#define TOT_CON				prod_num
#define SAMPLE_VAL			60

//list type 
#define FIB_TYPE 		1
#define PIT_TYPE   		2

/*define the transation conditions*/
#define DATA_FROM_APP   (OPC_INTRPT_STRM== intrpt_type && intrpt_stream == UPP_INPUT_STRM)
#define DATA_FROM_IP  	(OPC_INTRPT_STRM== intrpt_type && intrpt_stream == LOW_INPUT_STRM)
#define HELLO_INTRPT 	(OPC_INTRPT_SELF== intrpt_type && intrpt_code == HELLO_INTRPT_CODE)
#define DATA_HANDLE 	(OPC_INTRPT_SELF== intrpt_type && intrpt_code == DATA_HANDLE_CODE)
#define REQ_HANDLE 		(OPC_INTRPT_SELF== intrpt_type && intrpt_code == REQ_HANDLE_CODE)


typedef struct Neighbor_t{
	int 		addr;
	int			last_seq;
	int 		first_seq;
	Evhandle 	expire;

}Neighbor_t;

typedef struct NameAddr_t{
	List* 		addr_l;
	
	int 		content_name;
	int 		hop_limit;

}NameAddr_t;

typedef struct PIT_t{
	int 		content_name;
	int 		hop_limit;
	double 		life;
	
	Evhandle 	expire;
	
	Boolean		wireless;
	Boolean 	app;
	
}PIT_t;

/*
typedef struct Addr_t{
	int 		addr;
	
	NameAddr_t* root;
	Evhandle 	expire;
	
	
} Addr_t;
*/

typedef struct CS_t{
	int 		content_name;
	//static int	remain_size;
	double		access_time;
	double 		life; //7,11
	Packet*		content_pk;
	
	Evhandle 	expire;

}CS_t;

int* contentNum = OPC_NIL;
double* conInitLf = OPC_NIL;
double* reqInitLf = OPC_NIL;
double sampleTime=0;
int enc_num = 0;
double con_gen_rate;

//-------------------------------------init
int 		icdtn_get_ip_address_from_name(char* node_name);

//-------------------------------------pkt handle
Packet*		icdtn_hello_handle (Packet* p_bundle);
Packet*		icdtn_req_handle(Packet* pkt);
Packet*		icdtn_data_handle(Packet* pkt);
void 		icdtn_send_content( CS_t* cs_temp_t);


//-------------------------------list function
void 		icdtn_pit_l_copy (List* from, List* to);
int 		icdtn_list_elem_find (List* l, void* tar);
//int 		icdtn_list_elem_find_addr (List* l, int addr);
//int 		icdtn_list_elem_find_cname(List* l, int cname);

//int 		icdtn_pit_add (int content_name, int addr );
//int		icdtn_addr_add (int addr, NameAddr_t* temp, int list_type);
//int		icdtn_addr_add (int addr, NameAddr_t* temp, int list_type, double life);
//int 		icdtn_addr_t_delete (Addr_t* at);
int			icdtn_pit_add (int content_name, int addr, double life);
int 		icdtn_pit_delete (PIT_t* nat);
//int 		icdtn_NA_delete (NameAddr_t* nat);
//int 		icdtn_fib_add (int content_name, int addr );
int 		icdtn_cs_compare (const void* v1, const void* v2);
int 		icdtn_cs_t_delete (CS_t* ct);
int 		icdtn_cs_size_check ();
int 		icdtn_cs_space_check(int pk_size);
//CS_t* 		icdtn_cs_t_add (int content_name, Packet* payload);
CS_t* 		icdtn_cs_t_add (int content_name, Packet* payload, double life);

//---------------------------------call back function
void		icdtn_neighbor_t_delete_cb(Neighbor_t* nt, int code);
void 		icdtn_sim_end_cb(void* ptr, int code);
//void 		icdtn_addr_t_delete_cb (Addr_t* at,int code);

void		icdtn_cs_t_delete_cb (CS_t* ct,int code);
void		icdtn_con_num_cb (void* temp,int code);
void 		icdtn_pit_t_delete_cb (PIT_t* at,int code);
void 		icdtn_pit_copy_delete_cb(PIT_t* pit_temp,int code);
void 		icdtn_con_generate_cb(void* time,int content_name);
void 		icdtn_buff_stat_cb(void* ptr, int code);
void		icdtn_buff_age_stat_cb(void* ptr, int code);


/* End of Header Block */

#if !defined (VOSD_NO_FIN)
#undef	BIN
#undef	BOUT
#define	BIN		FIN_LOCAL_FIELD(_op_last_line_passed) = __LINE__ - _op_block_origin;
#define	BOUT	BIN
#define	BINIT	FIN_LOCAL_FIELD(_op_last_line_passed) = 0; _op_block_origin = __LINE__;
#else
#define	BINIT
#endif /* #if !defined (VOSD_NO_FIN) */



/* State variable definitions */
typedef struct
	{
	/* Internal state tracking for FSM */
	FSM_SYS_STATE
	/* State Variables */
	char	                   		name[32]                                        ;	/*  the node name  */
	double	                 		expire_time                                     ;
	double	                 		retrans_time                                    ;
	int	                    		content_seq                                     ;
	int	                    		cs_total_size                                   ;
	int	                    		cs_total_space                                  ;
	int	                    		hello_seq                                       ;
	int	                    		hop_lim                                         ;
	int	                    		self_ip_addr                                    ;
	List*	                  		cs_list                                         ;
	List*	                  		fib_list                                        ;
	List*	                  		neighbor_l                                      ;
	List*	                  		pit_list                                        ;
	Objid	                  		my_node_id                                      ;	/* the node id  */
	Objid	                  		my_objid                                        ;	/* the processor id  */
	OpT_Packet_Size	        		cs_remain_space                                 ;
	Packet*	                		pending_pk                                      ;
	Stathandle	             		stat_link_num                                   ;
	double	                 		fib_expir_time                                  ;
	double	                 		pit_expir_time                                  ;
	double	                 		cs_expir_time                                   ;
	double	                 		hello_interval                                  ;
	double	                 		allow_loss                                      ;
	int	                    		prod_f                                          ;
	PrgT_Bin_Hash_Table*	   		pit_ht                                          ;
	int	                    		prod_num                                        ;
	int	                    		pref_f                                          ;
	int*	                   		pro_rec                                         ;
	int	                    		OCP_f                                           ;
	} ICbundle_state;

#define name                    		op_sv_ptr->name
#define expire_time             		op_sv_ptr->expire_time
#define retrans_time            		op_sv_ptr->retrans_time
#define content_seq             		op_sv_ptr->content_seq
#define cs_total_size           		op_sv_ptr->cs_total_size
#define cs_total_space          		op_sv_ptr->cs_total_space
#define hello_seq               		op_sv_ptr->hello_seq
#define hop_lim                 		op_sv_ptr->hop_lim
#define self_ip_addr            		op_sv_ptr->self_ip_addr
#define cs_list                 		op_sv_ptr->cs_list
#define fib_list                		op_sv_ptr->fib_list
#define neighbor_l              		op_sv_ptr->neighbor_l
#define pit_list                		op_sv_ptr->pit_list
#define my_node_id              		op_sv_ptr->my_node_id
#define my_objid                		op_sv_ptr->my_objid
#define cs_remain_space         		op_sv_ptr->cs_remain_space
#define pending_pk              		op_sv_ptr->pending_pk
#define stat_link_num           		op_sv_ptr->stat_link_num
#define fib_expir_time          		op_sv_ptr->fib_expir_time
#define pit_expir_time          		op_sv_ptr->pit_expir_time
#define cs_expir_time           		op_sv_ptr->cs_expir_time
#define hello_interval          		op_sv_ptr->hello_interval
#define allow_loss              		op_sv_ptr->allow_loss
#define prod_f                  		op_sv_ptr->prod_f
#define pit_ht                  		op_sv_ptr->pit_ht
#define prod_num                		op_sv_ptr->prod_num
#define pref_f                  		op_sv_ptr->pref_f
#define pro_rec                 		op_sv_ptr->pro_rec
#define OCP_f                   		op_sv_ptr->OCP_f

/* These macro definitions will define a local variable called	*/
/* "op_sv_ptr" in each function containing a FIN statement.	*/
/* This variable points to the state variable data structure,	*/
/* and can be used from a C debugger to display their values.	*/
#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE
#define FIN_PREAMBLE_DEC	ICbundle_state *op_sv_ptr;
#define FIN_PREAMBLE_CODE	\
		op_sv_ptr = ((ICbundle_state *)(OP_SIM_CONTEXT_PTR->_op_mod_state_ptr));


/* Function Block */

#if !defined (VOSD_NO_FIN)
enum { _op_block_origin = __LINE__ + 2};
#endif

int icdtn_get_ip_address_from_name(char* node_name)
	{
		int i;
		int j;
		char id_str[8];
		int ip_address;
		FIN(get_ip_address_from_name_mac(char* node_name));
		i=5;
		j=0;
		while(*(node_name+i) != '\0')
			{
				id_str[j] = *(node_name+i);
				i++;
				j++;
			}
		id_str[j] = '\0';
		ip_address = atoi(id_str);
		FRET(ip_address);
	}

//------------------------------------pkt handle 
Packet*	icdtn_hello_handle(Packet* pkt){
	FIN (icdtn_hello_handle);
	int i;
	int l_size;
	//int addr_list_size;
	int src;
	int type;
	//int dest;
	int seq_no;
	Neighbor_t* nt;
	PIT_t* pit_temp;
	List* l_int = op_prg_list_create();
	List* l_temp = OPC_NIL;
	//Addr_t* 	addr_temp_t;
	Packet* req;
	
	op_pk_nfd_access (pkt,"pk_type",&type);
	op_pk_nfd_access (pkt,"src",&src);
	op_pk_nfd_access (pkt,"seq_no",&seq_no);
	op_pk_destroy (pkt);
	pkt = OPC_NIL;
	
	l_size = op_prg_list_size(neighbor_l);
	
	for (i = 0; i < l_size; i++){
		nt = (Neighbor_t*)op_prg_list_access(neighbor_l, i);
		if (nt->addr == src && nt->last_seq < seq_no  ){
			//printf("node %d get hello from %d\n",self_ip_addr,src);	
			nt->last_seq = seq_no;
			op_ev_cancel_if_pending( nt-> expire );
			nt-> expire = op_intrpt_schedule_call(op_sim_time()+HELLO_INTERVAL*ALLOW_LOSS, 
				0, icdtn_neighbor_t_delete_cb, nt);
			break;
		}
	}
	
	if (i == l_size){
		//printf("%d create a new neighbor t for %d\n",self_ip_addr, src);
		nt = op_prg_mem_alloc (sizeof (Neighbor_t) );
		nt-> addr = src;
		nt-> last_seq = seq_no;
		nt-> first_seq = seq_no;
		nt-> expire = op_intrpt_schedule_call(op_sim_time()+HELLO_INTERVAL*ALLOW_LOSS, 
			0, icdtn_neighbor_t_delete_cb, nt);
		op_prg_list_insert (neighbor_l, nt, OPC_LISTPOS_HEAD);
		
		op_stat_scalar_write ("occur - self addr", self_ip_addr);
		op_stat_scalar_write ("occur - neighbor addr", nt-> addr);
		op_stat_scalar_write ("occur - time", op_sim_time());
		if (self_ip_addr < nt-> addr)
			enc_num++;
	}
	
	//send PIT to neighbor
	//l_temp = prg_bin_hash_table_item_list_get(pit_ht);
	l_temp = prg_bin_hash_table_item_list_get(pit_ht);
	
	if ( (seq_no % 10 == 0) && l_temp != PRGC_NIL ){
		op_prg_list_elems_copy(l_temp,l_int);
		pit_temp = op_prg_list_access(l_temp,0);
		req = op_pk_create_fmt ("CCN_pk");
		op_pk_nfd_set	 (req, "pk_type", REQ_TYPE);
		op_pk_nfd_set	 (req, "name", pit_temp->content_name);
		op_pk_nfd_set	 (req, "hop_limit", pit_temp->hop_limit);
		op_pk_nfd_set	 (req, "src", self_ip_addr);
		op_pk_nfd_set 	 (req, "dest",IP_BROADCAST_ADDR);//yang 2.1
		op_pk_nfd_set_dbl(req, "intLife", pit_temp->life);
		//op_pk_nfd_set 	 (req, "name", l_temp, op_prg_mem_copy_create,
		//	op_prg_mem_free, sizeof (l_temp));
		op_pk_nfd_set	 (req, "name", (int)l_int);
		op_prg_odb_bkpt("int_gen");
			
		op_pk_send		 (req, LOW_OUTPUT_STRM);
	}

	
	FRET (OPC_NIL);
}
/*	
	//send PIT to neighbor
	l_size = op_prg_list_size(pit_list);
	for (i = 0; i < l_size; i++){
		pit_temp = (NameAddr_t*)op_prg_list_access(pit_list, i);
		
		if (pit_temp->addr_l == OPC_NIL){
			op_sim_end("un expected null list","","","");
		}
		if ( -1 == icdtn_list_elem_find_addr(pit_temp->addr_l,src)) {
			//printf("pit content = %d \n", pit_temp->content_name);
		
			req = op_pk_create_fmt ("CCN_pk");
			op_pk_nfd_set	 (req, "pk_type", REQ_TYPE);
			op_pk_nfd_set	 (req, "name", pit_temp->content_name);
			op_pk_nfd_set	 (req, "hop_limit", pit_temp->hop_limit);
			op_pk_nfd_set	 (req, "src", self_ip_addr);
			op_pk_nfd_set 	 (req, "dest",IP_BROADCAST_ADDR);//yang 2.1
			op_pk_nfd_set_dbl(req, "intLife", pit_temp->life);
			
			op_prg_odb_bkpt("int_gen");
			
			op_pk_send		 (req, LOW_OUTPUT_STRM);
		}
	}
*/	
	


Packet*	icdtn_req_handle(Packet* pkt){

	FIN (icdtn_req_handle)
		
	int 	content_name;
	int		hop_limit;
	int		src;
	int 	i,j;
//	int index,k;
	int		l_int;
//	Packet* pk_from_app;
	
	int cs_size;
	int pit_size;
//	int addr_list_size;
	
	int 	match;
	int 	match_pref;
	
	double intLife;
	
	
	
	//temp table
	CS_t*  cs_temp_t;
	PIT_t* pit_temp_t;
	PIT_t* recv_pit;
	List*  l_temp = OPC_NIL;
	
	//pending pk is interest/ req
	//op_pk_nfd_access(pkt, "pk_type", &content_name);
	op_pk_nfd_access(pkt, "name", &content_name);
	op_pk_nfd_access(pkt, "hop_limit", &hop_limit);
	op_pk_nfd_access(pkt, "src", &src);
	op_pk_nfd_access(pkt, "intLife", &intLife);
	//op_pk_nfd_get_ptr(pkt, "name", &l_temp);
	op_pk_nfd_access(pkt, "name", &l_int);
	l_temp = (List*)l_int;
	
	op_pk_destroy(pkt);
	//printf("\npkt = %o \n",pkt);
	pkt = OPC_NIL;

	cs_size  = op_prg_list_size(cs_list);
	//pit_size = op_prg_list_size(pit_list);
	//fib_size = op_prg_list_size(fib_list);
if (l_temp==OPC_NIL)
	op_sim_end("icdtn_req_handle","l_temp==OPC_NIL","","");
	
pit_size = op_prg_list_size(l_temp);
for(j = 0; j < pit_size; j++){
	recv_pit = op_prg_list_access(l_temp,j);
	content_name = recv_pit->content_name;
	intLife = recv_pit->life;
	//printf("node %d, get int %d, intlife %f\n",self_ip_addr,content_name, intLife);


	match = 0;//false
	
	if (pref_f)
		match_pref = 0;//false
	else
		match_pref = 1;//true
	
	for (i = 0; i < cs_size; i++){
		cs_temp_t = op_prg_list_access(cs_list, i);
		//--------------------------if content found
		if (cs_temp_t->content_name == content_name){
			//----------------------setup pkt header
	
			icdtn_send_content(cs_temp_t);
			
			op_stat_scalar_write ("npref - con_name", content_name);
			op_stat_scalar_write ("npref - time", op_sim_time());
			
			//printf("***node %d send con %d, pro_rec[content_name+1] = %d\n",self_ip_addr, content_name, pro_rec[content_name]);	
			printf("***node %d send con %d\n",self_ip_addr, content_name);	

			match = 1;//true
		}
		
		//--------------------------prefetching------------------------------------------------------------------
		//if (match && pref_f){
		if ( match && pref_f && (intLife+con_gen_rate>op_sim_time()) ){
			if ( cs_temp_t->content_name == (content_name+1) ){
				match_pref = 1;//true
				if ( OCP_f == 0 || pro_rec[content_name+1] == 0){
					
					icdtn_send_content(cs_temp_t);
					
					op_stat_scalar_write ("prefetch - con_name", content_name+1);
					op_stat_scalar_write ("prefetch - time", op_sim_time());
				
					printf("*******node %d pre-desseminate %d, pro_rec[content_name+1] = %d\n",self_ip_addr, content_name+1, pro_rec[content_name+1]);	
					op_prg_odb_bkpt("prefetching");
				}
			}
		}
//		else
//			printf("intLife+con_gen_rate=%f, op_sim_time=%f\n",intLife+con_gen_rate, op_sim_time());

		//------------------------------------------------------------------------------------------------------*/
		
		//printf("***node %d find %d, content %d, match %d, matchp %d\n",self_ip_addr, i, cs_temp_t->content_name, match, match_pref);	
		if (match && match_pref == 1){
			break;
			//printf("break\n");
		}
	}
	
	
	//if content not found
	if ( (i == cs_size) && (match == 0) ){
		pit_temp_t = prg_bin_hash_table_item_get(pit_ht, &content_name);
		
		if (pit_temp_t != PRGC_NIL){//update pit
		
			if (pit_temp_t->content_name != content_name){
				op_sim_end("icdtn_req_handle","wrong fetch","","");
			}
			if (src != self_ip_addr){
				pit_temp_t->wireless = OPC_TRUE;
			}
			if (pit_temp_t->life < intLife){
				//update pending interest table
				//printf("node %d update int %d\n",self_ip_addr, content_name);
				
				op_ev_cancel_if_pending(pit_temp_t->expire);
				pit_temp_t->expire = op_intrpt_schedule_call(intLife+PIT_EXPIR_TIME,
					PIT_TYPE, icdtn_pit_t_delete_cb, pit_temp_t );
				
				//discard req
			}
		}
		else{
			op_prg_odb_bkpt("req_han");
			printf("node %d get interest %d\n",self_ip_addr, content_name);
			icdtn_pit_add(content_name, src, intLife);
		}
	}//end if (i == cs_size)
}
	
	FRET (0)
}

/*	
		for (j = 0; j < pit_size; j++){
			//if found in PIT, update pit and discard int pkt
			pit_temp_t = op_prg_list_access(pit_list, j);
			//search by content name sub list
			if (pit_temp_t->content_name == content_name){

				addr_list_size = op_prg_list_size(pit_temp_t->addr_l);
				for (k = 0; k < addr_list_size; k++){ 
					addr_temp_t = op_prg_list_access(pit_temp_t->addr_l, k);
				
//*******************************update hop count*************************************
					if (addr_temp_t->addr == src){
						//update pending interest table
						//printf("node %d update int %d\n",self_ip_addr, content_name);
						op_ev_cancel_if_pending(addr_temp_t->expire);
						addr_temp_t->expire = op_intrpt_schedule_call(op_sim_time()+PIT_EXPIR_TIME,
							PIT_TYPE, icdtn_addr_t_delete_cb, addr_temp_t );
				
						break; //discard req
					}	
				}
				//addr not found
				if (k == addr_list_size){
					icdtn_addr_add(src, pit_temp_t, PIT_TYPE, intLife);	
				}
			}
		}	

				
		//if PI with content name is not found, add new PI and forward it
		if (j == pit_size){
			printf("node %d get interest %d\n",self_ip_addr, content_name);
			icdtn_pit_add(content_name, src, intLife);
		}// end if (j == pit_size)
		
	}//end if (i == cs_size)

	FRET (0)*/


Packet*	icdtn_data_handle(Packet* pkt){

	FIN (icdtn_data_handle)
		
	int 	content_name;
	int		hop_limit;
	int		src;
	int 	i;
//	int		j, k;
	double 	intLife;
	Packet* payload;
	Packet* pk_from_mac;
		
	int cs_size;
//	int pit_size;
//	int addr_list_size;
	int neigh_list_size;

	//temp table
	CS_t*  cs_temp_t;
	PIT_t* pit_temp_t;
//	Addr_t*		addr_temp_t;
		
	op_prg_odb_bkpt("data_han");
	
	//pending pk is content
	op_pk_nfd_access(pkt, "name", &content_name);
	op_pk_nfd_access(pkt, "hop_limit", &hop_limit);
	op_pk_nfd_access(pkt, "src", &src);
	op_pk_nfd_access(pkt, "intLife", &intLife);
	op_pk_nfd_get_pkt(pkt, "payload", &payload);
	op_pk_destroy(pkt);
	pkt = OPC_NIL;
	
	op_stat_scalar_write("con exch-name", content_name);
	op_stat_scalar_write("con exch-self", self_ip_addr);
	op_stat_scalar_write("con exch-name", src);


	if (content_name == 310)
		op_prg_odb_bkpt("310");
	
	cs_size = op_prg_list_size(cs_list);
	//pit_size = op_prg_list_size(pit_list);
	//fib_size = op_prg_list_size(fib_list);
	neigh_list_size = op_prg_list_size(neighbor_l);

	for (i = 0; i < cs_size; i++){
		cs_temp_t = op_prg_list_access(cs_list, i);
		//if content found
		if (cs_temp_t->content_name == content_name){
			//discard pkt
			op_pk_destroy (payload);
			break;
		}
	}
	//if content not found
	if (i == cs_size){
		//save content to cache
		if (intLife + CS_EXPIR_TIME > op_sim_time()){//check content life time
		
		
			cs_temp_t = icdtn_cs_t_add (content_name, payload, intLife);
		
			pit_temp_t = prg_bin_hash_table_item_remove(pit_ht, &content_name);
			if (pit_temp_t!= PRGC_NIL){
				if (pit_temp_t->content_name != content_name){
					char str1[32] = {0};
					sprintf(str1, "found cn = %d", pit_temp_t->content_name);
					char str2[32] = {0};
					sprintf(str2, "target cn = %d", content_name);
					op_sim_end("icdtn_data_handle", "wrong fetch", str1, str2);
				}
				if (pit_temp_t->app == OPC_TRUE){
					pk_from_mac = op_pk_create_fmt ("ccn_app_data");
					op_pk_nfd_set	 (pk_from_mac, "type", DATA_APP_CON);
					op_pk_nfd_set	 (pk_from_mac, "name", content_name);
					op_pk_nfd_set_pkt(pk_from_mac, "payload", op_pk_copy(cs_temp_t->content_pk) );
					op_pk_nfd_set	 (pk_from_mac, "src", self_ip_addr);

					op_pk_send		 (pk_from_mac, UPP_OUTPUT_STRM);
			
				}
			
			
				icdtn_pit_delete (pit_temp_t);
			}
//*/
		}
		else{
			op_pk_destroy (payload);//delete expired content
		}
		
	}//end if (i == cs_size)


	FRET (0)
}
		
/*
		for (j = 0; j < pit_size; j++){
			//if found in PIT, send it to app layer
			pit_temp_t = op_prg_list_access(pit_list, j);
			if (pit_temp_t->content_name == content_name){
		
				addr_list_size = op_prg_list_size(pit_temp_t->addr_l);
				for (k = 0; k < addr_list_size; k++){
					addr_temp_t = op_prg_list_access(pit_temp_t->addr_l, k);
					if (addr_temp_t->addr == self_ip_addr){
					
						pk_from_mac = op_pk_create_fmt ("ccn_app_data");
						op_pk_nfd_set	 (pk_from_mac, "type", DATA_APP_CON);
						op_pk_nfd_set	 (pk_from_mac, "name", content_name);
						op_pk_nfd_set_pkt(pk_from_mac, "payload", op_pk_copy(cs_temp_t->content_pk) );
						op_pk_nfd_set	 (pk_from_mac, "src", self_ip_addr);

						op_pk_send		 (pk_from_mac, UPP_OUTPUT_STRM);
							
						//delete pit
						
						break;
					}
				}
			
				op_prg_list_remove(pit_list,j);
				icdtn_NA_delete (pit_temp_t);
			
				break;
			}//end if (pit_temp_t->content_name == content_name)
		} //for (j = 0; j < pit_size; j++
//*/
	
void icdtn_send_content(CS_t* cs_temp_t){

	FIN (icdtn_send_content)
	PIT_t* pit_temp_t;
	char   con_str[20] = {0};
	
	if (pref_f){
		pro_rec[cs_temp_t->content_name] = 1;
		//printf("prefetch %d\n",pro_rec[cs_temp_t->content_name]);
	}
		
	Packet* pk_from_app = op_pk_create_fmt ("CCN_pk");
	
	if (cs_temp_t->life == 0){
		cs_temp_t->life = op_sim_time();
		conInitLf [ cs_temp_t->content_name ] = cs_temp_t->life;
	}
		
		
	
	op_pk_nfd_set	 (pk_from_app, "pk_type", 	CONTENT_TYPE);
	op_pk_nfd_set	 (pk_from_app, "name", 		cs_temp_t->content_name);
	op_pk_nfd_set	 (pk_from_app, "hop_limit", HOP_LIMIT);
	op_pk_nfd_set_dbl(pk_from_app, "intLife", 	cs_temp_t->life);
	op_pk_nfd_set_pkt(pk_from_app, "payload", 	op_pk_copy(cs_temp_t->content_pk) );
	op_pk_nfd_set	 (pk_from_app, "src", 		self_ip_addr);
	op_pk_nfd_set	 (pk_from_app, "dest", 		IP_BROADCAST_ADDR);
			
	op_pk_send		 (pk_from_app, LOW_OUTPUT_STRM);
		
	op_stat_scalar_write ("content - con_name", cs_temp_t->content_name);
	op_stat_scalar_write ("content - send_time", op_sim_time());
	
	pit_temp_t = prg_bin_hash_table_item_get(pit_ht, &(cs_temp_t->content_name) );
	if (pit_temp_t != PRGC_NIL){
			sprintf (con_str, "pit num %d", pit_temp_t->content_name);
			op_sim_end("icdtn_req_handle","duplicate pit"
				,con_str ,"");
	}
	
	FOUT
}
//-------------------------------list function

void icdtn_pit_l_copy (List* from, List* to){
	FIN (icdtn_pit_l_copy)

	//printf("node %d add addr %d to new PIT %d\n",self_ip_addr, addr, content_name);
	
	int i;
	int size = op_prg_list_size(from);
	PIT_t *temp, *copy;
	
	for (i = 0;i<size;i++){
		temp = op_prg_list_access(from,i);
/*		copy = (PIT_t*)op_prg_mem_alloc(sizeof (PIT_t) );
//		printf("node %d copy pit %d : 0x%x\n",self_ip_addr, temp->content_name, temp);

	
		copy->content_name = temp->content_name;
		copy->hop_limit = temp->hop_limit ;
		copy->life = temp->life;
	
		copy->wireless = temp->wireless;
		copy->app = OPC_FALSE;
*/
		copy = (PIT_t*)op_prg_mem_copy_create(temp, sizeof (PIT_t) );
		copy->expire = op_intrpt_schedule_call(copy->life+PIT_EXPIR_TIME,
			0, icdtn_pit_copy_delete_cb, copy);
		
		op_prg_list_insert(to,copy,OPC_LISTPOS_TAIL);
		
		//printf("**node %d copy pit %d\n", self_ip_addr, temp->content_name);
	}
	
	FOUT
}



int icdtn_list_elem_find(List* l, void* tar){
	FIN (icdtn_list_elem_find)
	int i; 
	int l_size = op_prg_list_size (l);
	void* ptr; 
	
	for (i = 0; i < l_size; i++){
		ptr = (void*)op_prg_list_access(l, i);
		
		if ( tar == ptr ){
			
			FRET (i)
		}
	}
	
	FRET (-1)
}
/*
int icdtn_list_elem_find_addr (List* l, int addr){
	FIN (icdtn_list_elem_find_addr)
	int i; 
	int l_size = op_prg_list_size (l);
	Addr_t* ptr; 
	
	for (i = 0; i < l_size; i++){
		ptr = (Addr_t*)op_prg_list_access(l, i);
		
		if ( addr == ptr->addr ){
			
			FRET (i)
		}
	}
	
	FRET (-1)
}

int icdtn_list_elem_find_cname(List* l, int cname){
	FIN (icdtn_list_elem_find)
	int i; 
	int l_size = op_prg_list_size (l);
	NameAddr_t* ptr; 
	
	for (i = 0; i < l_size; i++){
		ptr = (NameAddr_t*)op_prg_list_access(l, i);
		
		if ( cname == ptr->content_name ){
			
			FRET (i)
		}
	}
	
	FRET (-1)
}*/

/*
int icdtn_addr_add (int addr, NameAddr_t* temp, int list_type){
	FIN (icdtn_addr_add)	
		
	if (temp == OPC_NIL)
		op_sim_end("invalid parameter","","","");
	
	if (prod_f == 0)
		contentNum[temp->content_name]+=0.5;
	
	Addr_t* addr_t_temp = op_prg_mem_alloc( sizeof(Addr_t) );
	addr_t_temp->addr = addr;
	addr_t_temp->root = temp;
	
	//printf("node %d add addr %d to pit %d: %o\n",self_ip_addr, addr, temp->content_name, addr_t_temp);

	
	switch (list_type ){
		case FIB_TYPE :
			addr_t_temp->expire = op_intrpt_schedule_call(op_sim_time()+FIB_EXPIR_TIME,
				FIB_TYPE, icdtn_addr_t_delete_cb, addr_t_temp);
			break;
		case PIT_TYPE:
			addr_t_temp->expire = op_intrpt_schedule_call(op_sim_time()+PIT_EXPIR_TIME,
				PIT_TYPE, icdtn_addr_t_delete_cb, addr_t_temp);
			break;
		default:
			op_sim_end("icdtn addr add","","","");
	}
	
	
	op_prg_list_insert(temp->addr_l, addr_t_temp, OPC_LISTPOS_TAIL);
		
	FRET(0)
}


int icdtn_addr_t_delete (Addr_t* at){
	FIN (icdtn_addr_t_delete)
		
	op_ev_cancel_if_pending( at-> expire ); 
	op_prg_mem_free(at);
	
	FRET (0)
}
//*/
/*
int icdtn_pit_add (int content_name, int addr ){
	FIN (icdtn_pit_add)

	//printf("node %d add addr %d to new PIT %d\n",self_ip_addr, addr, content_name);

	NameAddr_t* temp = op_prg_mem_alloc(sizeof (NameAddr_t) );
	
	temp->content_name = content_name;
	temp->addr_l = op_prg_list_create();
	
	icdtn_addr_add(addr, temp, PIT_TYPE);
		
	op_prg_list_insert(pit_list, temp, OPC_LISTPOS_TAIL);
	
	FRET (0)
}//*/

int icdtn_pit_add (int content_name, int addr, double life ){
	FIN (icdtn_pit_add)

	//printf("node %d add addr %d to new PIT %d\n",self_ip_addr, addr, content_name);
	if (life+PIT_EXPIR_TIME <= op_sim_time()){
		FRET (0)
	}
			
	PIT_t* temp = op_prg_mem_alloc(sizeof (PIT_t) );
	
	temp->content_name = content_name;
	temp->life = life;
	if (addr == self_ip_addr)
		temp->app = OPC_TRUE;
	else
		temp->wireless = OPC_TRUE;
	
	temp->expire = op_intrpt_schedule_call(life+PIT_EXPIR_TIME,
		PIT_TYPE, icdtn_pit_t_delete_cb, temp);

	prg_bin_hash_table_item_insert(pit_ht, &content_name, temp, PRGC_NIL);
	
	FRET (0)
}

int icdtn_pit_delete (PIT_t* temp){
	FIN (icdtn_pit_delete)
		
		op_ev_cancel_if_pending( temp-> expire ); 
		op_prg_mem_free(temp);
	FRET (0)
}//*/
/*
int icdtn_NA_delete (NameAddr_t* nat){
	FIN (icdtn_addr_t_delete)
		int l_size = op_prg_list_size (nat->addr_l);
		Addr_t* at;
		
		printf("node %d remove pit \n",self_ip_addr);
		for (int i = 0; i<l_size; i++){
			at = op_prg_list_remove(nat->addr_l, 0);
			icdtn_addr_t_delete(at);
		}
			
		op_prg_mem_free(nat);
	FRET (0)
}//*/

/*
int icdtn_fib_add (int content_name, int addr ){
	FIN (icdtn_fib_add)

	NameAddr_t* temp = op_prg_mem_alloc(sizeof (NameAddr_t) );
	
	temp->content_name = content_name;
	temp->addr_l = op_prg_list_create();
	
	//icdtn_addr_add(addr, temp, FIB_TYPE);
	icdtn_addr_add(addr, temp, FIB_TYPE, op_sim_time());
		
	op_prg_list_insert(fib_list, temp, OPC_LISTPOS_TAIL);
	
	FRET (0)
}
//*/


int icdtn_cs_compare (const void* v1, const void* v2){
	FIN (icdtn_cs_compare)
		
	int time1 = ( (CS_t*)v1 )->content_name;
	int time2 = ( (CS_t*)v2 )->content_name;
	
	if ( time1 >= time2 ){
		FRET (-1); //tail
	}
	else {
		FRET (1); //head
	}

}

int icdtn_cs_t_delete (CS_t* ct){
	FIN (icdtn_cs_t_delete)
		
	//printf("---node %d content delete cs =%d, life = %f\n",self_ip_addr, ct->content_name, ct->life);
	contentNum[ct->content_name]--;
	op_pk_destroy (ct->content_pk);
	op_ev_cancel_if_pending (ct->expire);
	op_prg_mem_free (ct);
		
	FRET (0)
}

int icdtn_cs_size_check (){
	FIN (icdtn_cs_size_check)
		
	CS_t* ct_temp;
	int cs_size = op_prg_list_size(cs_list);
	
	//printf("cs check cs size %d\n",cs_size);
	
	if (prod_f == 0 && cs_size == CS_TOTAL_SIZE){
		ct_temp = op_prg_list_remove(cs_list, OPC_LISTPOS_HEAD);
		printf("node %d buffer full cs_t %d removed\n",self_ip_addr, ct_temp->content_name);
		op_stat_scalar_write("buff drop - content name"	, ct_temp->content_name );
		op_stat_scalar_write("buff drop - node id"			, self_ip_addr );
		op_stat_scalar_write("buff drop - time"				, op_sim_time());
		icdtn_cs_t_delete (ct_temp);
	}
		
	FRET (0)
}

int icdtn_cs_space_check(int pk_size){
	FIN (icdtn_cs_space_check)
		
	FRET (0)
}
/*
CS_t* icdtn_cs_t_add (int content_name, Packet* payload){
	FIN (icdtn_cs_t_add)
		
	icdtn_cs_size_check();
	
	//printf("before prod_f node %d, prod_f %d\n",self_ip_addr,prod_f);
	//stat
	if (prod_f == 0)
		contentNum[content_name]++;
	//else
	//	contentNum[content_name] = 0;
		
	//printf("node %d content added to cs, num=%d\n",self_ip_addr, contentNum[content_name]);
	
	CS_t* cs_temp_t = op_prg_mem_alloc(sizeof (CS_t) );
	cs_temp_t->content_name = content_name;
	cs_temp_t->access_time = op_sim_time();
	cs_temp_t->content_pk = payload;
	if (prod_f == 0)
		cs_temp_t->expire = op_intrpt_schedule_call(op_sim_time()+CS_EXPIR_TIME,
			0, icdtn_cs_t_delete_cb, (void*)cs_temp_t);
	op_prg_list_insert_sorted(cs_list, cs_temp_t, icdtn_cs_compare);
	
	FRET (cs_temp_t)
}//*/

CS_t* icdtn_cs_t_add (int content_name, Packet* payload, double life){
	FIN (icdtn_cs_t_add)
	
//	PIT_t* 		pit_temp_t;
//	Packet* 	pk_from_mac;
		
	icdtn_cs_size_check();
	
	//printf("before prod_f node %d, prod_f %d\n",self_ip_addr,prod_f);
	
	if (prod_f == 0)
		contentNum[content_name]++;
	
	
	
	CS_t* cs_temp_t = op_prg_mem_alloc(sizeof (CS_t) );
	cs_temp_t->content_name = content_name;
	cs_temp_t->access_time = op_sim_time();
	cs_temp_t->life = life;
	cs_temp_t->content_pk = payload;
	
	
	if (prod_f == 0){
		if (life+CS_EXPIR_TIME < op_sim_time())
			op_sim_end("wrong content life time","icdtn_cs_t_add","","");
		//printf("node %d content %d added to cs, num=%d, life = %f\n",self_ip_addr, content_name, contentNum[content_name], life);
		cs_temp_t->expire = op_intrpt_schedule_call(life+CS_EXPIR_TIME, 0, icdtn_cs_t_delete_cb, (void*)cs_temp_t);
	}
	else
		;//printf("producer %d content %d added to cs, num=%d, life = %f\n",self_ip_addr, content_name, contentNum[content_name], life);
		//cs_temp_t->expire = op_intrpt_schedule_call(life+CS_EXPIR_TIME,
		//	0, icdtn_cs_t_delete_cb, (void*)cs_temp_t);
	op_prg_list_insert_sorted(cs_list, cs_temp_t, icdtn_cs_compare);
	//op_prg_list_insert (cs_list, cs_temp_t, OPC_LISTPOS_TAIL);
	
	
	FRET (cs_temp_t)
}

//-------------------------------call back function ----------------------------
void icdtn_neighbor_t_delete_cb(Neighbor_t* nt, int code){
	FIN (icdtn_neighbor_t_delete_cb);

	int i = 0;
	int l_size = op_prg_list_size(neighbor_l);
	double hello_count = 0;
	Neighbor_t* nt_temp;
	
	//printf("try to release %o\n", nt);
	for (i = 0; i < l_size; i++){
		nt_temp = (Neighbor_t*)op_prg_list_access(neighbor_l, i);
		if ( nt->addr == nt_temp->addr  ){
			nt_temp = (Neighbor_t*)op_prg_list_remove(neighbor_l, i);
			
			//printf("node %d release nei %d: %o\n", self_ip_addr, nt_temp->addr, nt);
			hello_count = (double)(nt_temp->last_seq - nt_temp->first_seq + 1);
			op_stat_scalar_write ("link time - self addr", self_ip_addr);
			op_stat_scalar_write ("link time - neighbor addr", nt_temp-> addr);
			op_stat_scalar_write ("link time - link time", hello_count*HELLO_INTERVAL);
			
			op_ev_cancel_if_pending( nt_temp-> expire ); 
			op_prg_mem_free(nt_temp);
			
			break;
		}
		
	}
	if (i == l_size){
		op_sim_end("neighbor_t delete error","","","");
	}
			

	FOUT;
}

void icdtn_sim_end_cb(void* ptr, int code){
	FIN (icdtn_sim_end_cb)
		
	int i = 0;
	int l_size = op_prg_list_size(neighbor_l);
	double hello_count = 0;
	Neighbor_t* nt_temp;
	
	op_prg_odb_bkpt("end");
	//printf("node %d end of sim! list size = %d\n",self_ip_addr, l_size);
	for (i = 0; i < l_size; i++){
		nt_temp = (Neighbor_t*)op_prg_list_access(neighbor_l, i);
			
		hello_count = (double)(nt_temp->last_seq - nt_temp->first_seq + 1);
		op_stat_scalar_write ("link time - self addr", self_ip_addr);
		op_stat_scalar_write ("link time - neighbor addr", nt_temp-> addr);
		op_stat_scalar_write ("link time - link time", hello_count*HELLO_INTERVAL);
	}
	
	FOUT

}
/*
void icdtn_addr_t_delete_cb (Addr_t* at,int code){
	FIN (icdtn_addr_t_delete_cb);
	
	int i = 0;
	int j = 0;
	int l_size = 0;
	int addr_l_size = 0;
	double hello_count = 0;
	Addr_t* at_temp;
	NameAddr_t* nat_temp;
	NameAddr_t* nat_temp_l;
	List* l_temp = OPC_NIL;
	
	if (at->root != OPC_NIL)
		nat_temp = at->root;
	else{
		printf("node %d addr = %d: %o\n", self_ip_addr, at->addr, at);	
		
		op_sim_end("in addr_t_delete_cb","NULL root","","");
		//FOUT
	}
	
	switch (code) {
		case FIB_TYPE:
			l_temp = fib_list;
			break;
		case PIT_TYPE:
			l_temp = pit_list;
			break;
		default:
			op_sim_end("in addr_t_delete_cb","invalid code","","");
	}
	
	//printf("node %d addr = %d: %o\n", self_ip_addr, at->addr, at);

	l_size = op_prg_list_size (nat_temp->addr_l);
	for (i = 0; i < l_size; i++){
	
		at_temp = (Addr_t*)op_prg_list_access(nat_temp->addr_l, i);
		//printf("node %d have interest %d\n", self_ip_addr, at_temp->root->content_name);
		if (at_temp->addr == at->addr){
			op_prg_list_remove (nat_temp->addr_l, i);
			printf("node %d release interest %d time %f\n",self_ip_addr, nat_temp->content_name, op_sim_time());
			op_ev_cancel_if_pending( at_temp-> expire ); 
			op_prg_mem_free(at_temp);
			
			break;
		}
	}
	
	if (i == l_size){
		op_sim_end("in addr_t_delete_cb","","","");
	}
	//if no elements in addr list
	if (op_prg_list_size (nat_temp->addr_l) == 0){
		l_size = op_prg_list_size (l_temp);
		for (i = 0; i < l_size; i++){
			nat_temp_l = (NameAddr_t*)op_prg_list_access(l_temp, i);
			//printf("node %d have interest %d\n",self_ip_addr, at_temp->root->content_name);
			if (nat_temp_l == nat_temp){
				op_prg_list_remove (l_temp, i);
				op_prg_list_free (nat_temp->addr_l);
				op_prg_mem_free (nat_temp);
				break;
			}
		}
		
	}
	
	FOUT ;
}//*/

void icdtn_pit_t_delete_cb (PIT_t* pit_temp,int code){
	FIN (icdtn_pit_t_delete_cb);
	
	int i = 0;
	int j = 0;
	int l_size = 0;
	int addr_l_size = 0;
	
	PIT_t* temp;
	
	
	if (code != PIT_TYPE) {
		op_sim_end("in NA_t_delete_cb","invalid code","","");
	}
	
	//printf("node %d addr = %d: %o\n", self_ip_addr, at->addr, at);
	
	
	temp = prg_bin_hash_table_item_remove(pit_ht, &(pit_temp->content_name));
	if (temp!= PRGC_NIL){
		if (temp != pit_temp)
			op_sim_end("icdtn_pit_t_delete_cb","wrong pit","","");
		
		//printf("node %d release interest %d time %f\n",self_ip_addr, pit_temp->content_name, op_sim_time());
	
		op_ev_cancel_if_pending( pit_temp-> expire ); 
		op_prg_mem_free(pit_temp);
	}
	else{
		op_sim_end("icdtn_pit_t_delete_cb","cannot find pit","","");
	}
	
	FOUT ;
}

void icdtn_pit_copy_delete_cb(PIT_t* pit_temp,int code){
	FIN (icdtn_pit_copy_delete_cb)
	
	icdtn_pit_delete(pit_temp);
		
	FOUT
}

void icdtn_cs_t_delete_cb (CS_t* ct,int code){
	FIN (icdtn_cs_t_delete_cb)
		
	int i = 0;
	int l_size = 0;
	double hello_count = 0;
	CS_t* ct_temp;
		
	printf("node %d ct = %d expire intlife = %f\n", self_ip_addr, ct->content_name, ct->life);
	op_prg_odb_bkpt("cs delete");
	l_size = op_prg_list_size (cs_list);
	for (i = 0; i < l_size; i++){
		ct_temp = (CS_t*)op_prg_list_access(cs_list, i);
		if ( ct->content_name == ct_temp->content_name ){
//*****************************************cache size********************************
		
			op_prg_list_remove (cs_list, i);
			icdtn_cs_t_delete (ct);
			
			break;	
		}
		
	}
	if (i == l_size){
		op_sim_end("cs_t delete error","","","");
	}
	
	FOUT
}

void icdtn_con_num_cb(void* temp,int code){
	FIN (icdtn_con_num_cb)
	int i;
	
	if (code == -1){
		if (op_sim_time() >= sampleTime+SAMPLE_VAL){
			//printf ("---------------------------------------------------------- \n");
			for(i=0;i<TOT_CON;i++){
				if (contentNum[i]>0){
						if (i==20)
							printf ( "con_name %d, con_num %d\n", i, contentNum[i] );
						op_stat_scalar_write ("con - con_name", i);
						op_stat_scalar_write ("con - con_num", contentNum[i]);
						op_stat_scalar_write ("con - time", op_sim_time());
				}
			
			}
			//printf ("---------------------------------------------------------- \n");

		
		}
	
		sampleTime = op_sim_time();
		op_intrpt_schedule_call (op_sim_time()+SAMPLE_VAL,-1,icdtn_con_num_cb,OPC_NIL);
	}
	else{
		if ( self_ip_addr == 1){
/*			if (code==1){
			printf ("---------------------------------------------------------- \n");
			
			printf ( "app con_name %d, con_num %d,initlf %f\n", code, contentNum[code], conInitLf[code] );
			printf ( "int life %f, time %f\n", con_gen_rate*code+CS_EXPIR_TIME, op_sim_time() );
			printf("reqInitLf[%d]=%f, op_sim_time=%f, conInitLf[code] + CS_EXPIR_TIME*1.5=%f, conInitLf[code]=%f \n",
						code, reqInitLf[code], op_sim_time(), conInitLf[code] + CS_EXPIR_TIME*1.5, conInitLf[code]);
			printf ("---------------------------------------------------------- \n");
			}

			op_stat_scalar_write ("app - con_name", code);
			op_stat_scalar_write ("app - con_num", contentNum[code]);
			op_stat_scalar_write ("app - time", op_sim_time());//*/
			
			//if ( op_sim_time() < conInitLf[code] + CS_EXPIR_TIME*1.5 
			//	|| (conInitLf[code] == 0.0 && con_gen_rate*(double)code+CS_EXPIR_TIME>op_sim_time() ) )
		
			if ( reqInitLf[code] > 0.0 ){
			}
			else{
				printf ("---------------------------------------------------------- \n");
			
				//printf ( "app con_name %d, con_num %d,initlf %f\n", code, contentNum[code], conInitLf[code] );
				//printf ( "int life %f, time %f\n", con_gen_rate*code+CS_EXPIR_TIME, op_sim_time() );
				printf("reqInitLf[%d]=%f, op_sim_time=%f, conInitLf[code] + CS_EXPIR_TIME*1.5=%f, conInitLf[code]=%f \n",
						code, reqInitLf[code], op_sim_time(), conInitLf[code] + CS_EXPIR_TIME*1.5, conInitLf[code]);
				//printf ("---------------------------------------------------------- \n");
			}
				

				op_stat_scalar_write ("app - con_name", code);
				op_stat_scalar_write ("app - con_num", contentNum[code]);
				op_stat_scalar_write ("app - time", op_sim_time());
				
				//when content kept in producer, conInitLf[code] == 0.0, conInitLf[code] + CS_EXPIR_TIME*1.5 = CS_EXPIR_TIME*1.5
				//which is likely smaller than req init lift, causing problem
				//this call back should allow count down start until conInitLf[code] > 0.0
				if ( conInitLf[code] > 0.0 && op_sim_time() < conInitLf[code] + CS_EXPIR_TIME*1.5)
					op_intrpt_schedule_call (op_sim_time()+SAMPLE_VAL,code,icdtn_con_num_cb,OPC_NIL);
				else if (conInitLf[code] == 0.0 && op_sim_time() < reqInitLf[code] + PIT_EXPIR_TIME*1.5)
					op_intrpt_schedule_call (op_sim_time()+SAMPLE_VAL,code,icdtn_con_num_cb,OPC_NIL);
				else{
					printf("reqInitLf[%d]=%f, op_sim_time=%f, conInitLf[code] + CS_EXPIR_TIME*1.5=%f, conInitLf[code]=%f \n",
						code, reqInitLf[code], op_sim_time(), conInitLf[code] + CS_EXPIR_TIME*1.5, conInitLf[code]);
					//op_sim_end("icdtn_con_num_cb","unexpected time combination","","");
					printf("content expire, call back terminated\n");
				}
			//}
			//special for aap
			//when content prefetched, req is not generated
			//should wait until req generated
			//else if (pref_f == 1 && op_sim_time() < conInitLf[code] + CS_EXPIR_TIME*1.5){
			//	op_intrpt_schedule_call (op_sim_time()+SAMPLE_VAL,code,icdtn_con_num_cb,OPC_NIL);
			//}
			
		}
	}
	
	FOUT 
}


void icdtn_con_generate_cb(void* time, int content_name){
	FIN ( icdtn_con_generate_cb )

	CS_t*  cs_temp_t = OPC_NIL;
	Packet* pk_from_app = op_pk_create_fmt ("CCN_pk");
	
//	printf("");
	
	op_pk_nfd_set	 (pk_from_app, "pk_type", 	CONTENT_TYPE);
	op_pk_nfd_set	 (pk_from_app, "name", 		content_name);
	op_pk_nfd_set	 (pk_from_app, "hop_limit", HOP_LIMIT);
	op_pk_nfd_set_dbl(pk_from_app, "intLife", 	0);
	op_pk_nfd_set_pkt(pk_from_app, "payload", 	op_pk_create(4000 + (int)op_dist_uniform(45000)) );
	op_pk_nfd_set	 (pk_from_app, "src", 		self_ip_addr);
	op_pk_nfd_set	 (pk_from_app, "dest", 		IP_BROADCAST_ADDR);
			
	icdtn_data_handle(pk_from_app);
	
	content_name++;
	if (content_name < TOT_CON)
		op_intrpt_schedule_call (op_sim_time()+0.1, content_name,icdtn_con_generate_cb,OPC_NIL);
	
	FOUT 
}

void icdtn_buff_stat_cb(void* ptr, int code){
	FIN (icdtn_buff_stat_cb)
//	int i=0;
//	CS_t*  ct_temp = OPC_NIL;
	
	op_stat_scalar_write ("buff - time", op_sim_time());
	op_stat_scalar_write ("buff - self addr", self_ip_addr);
	op_stat_scalar_write ("buff - size", op_prg_list_size(cs_list));
	

	op_intrpt_schedule_call (op_sim_time()+SAMPLE_VAL, 1, icdtn_buff_stat_cb,OPC_NIL);
	
	FOUT

}

//mar28 added
void icdtn_buff_age_stat_cb(void* ptr, int code){
	FIN (icdtn_buff_age_stat_cb)
	int i=0;
	CS_t*  ct_temp = OPC_NIL;
	if (prod_f == 1)
		FOUT
			
	for (i=0; i<op_prg_list_size(cs_list); i++){
		ct_temp = op_prg_list_access(cs_list, i);
		//printf("node %d buffer full cs_t %d removed\n",self_ip_addr, ct_temp->content_name);
		op_stat_scalar_write("buff age - content name"	, ct_temp->content_name );
		op_stat_scalar_write("buff age - node addr"		, self_ip_addr );
		op_stat_scalar_write("buff age - con age"		, op_sim_time() - conInitLf [ ct_temp->content_name ]);
	}
	
	op_intrpt_schedule_call (op_sim_time()+SAMPLE_VAL*10, 1, icdtn_buff_age_stat_cb,OPC_NIL);
	
	FOUT

}

/* End of Function Block */

/* Undefine optional tracing in FIN/FOUT/FRET */
/* The FSM has its own tracing code and the other */
/* functions should not have any tracing.		  */
#undef FIN_TRACING
#define FIN_TRACING

#undef FOUTRET_TRACING
#define FOUTRET_TRACING

#if defined (__cplusplus)
extern "C" {
#endif
	void ICbundle (OP_SIM_CONTEXT_ARG_OPT);
	VosT_Obtype _op_ICbundle_init (int * init_block_ptr);
	void _op_ICbundle_diag (OP_SIM_CONTEXT_ARG_OPT);
	void _op_ICbundle_terminate (OP_SIM_CONTEXT_ARG_OPT);
	VosT_Address _op_ICbundle_alloc (VosT_Obtype, int);
	void _op_ICbundle_svar (void *, const char *, void **);


#if defined (__cplusplus)
} /* end of 'extern "C"' */
#endif




/* Process model interrupt handling procedure */


void
ICbundle (OP_SIM_CONTEXT_ARG_OPT)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	FIN_MT (ICbundle ());

		{
		/* Temporary Variables */
		int i;
		//, j, k;
		//int index;
		
		// get interupt type 
		int intrpt_type; 
		int intrpt_stream;
		int intrpt_code;
		
		//pk attr
		int 	type;
		int 	content_name;
		//int		hop_limit;
		//int		src;
		//Packet* payload;
		
		//pk handle
		Packet* pk_from_app;
		Packet* pk_from_mac;
		
		//list size
		//int neighbor_size;
		int cs_size;
		int pit_size;
		//int fib_size;
		//int addr_list_size;
		//int neigh_list_size;
		
		//temp table
		CS_t*  cs_temp_t;
		//NameAddr_t* pit_temp_t;
		//NameAddr_t* fib_temp_t;
		//Addr_t*		addr_temp_t;
		//Neighbor_t* nei_temp_t;
		PIT_t* pit_temp;
		
		Objid protocol_compound;
		Objid oid;
		/* End of Temporary Variables */


		FSM_ENTER ("ICbundle")

		FSM_BLOCK_SWITCH
			{
			/*---------------------------------------------------------*/
			/** state (init) enter executives **/
			FSM_STATE_ENTER_FORCED_NOLABEL (0, "init", "ICbundle [init enter execs]")
				FSM_PROFILE_SECTION_IN ("ICbundle [init enter execs]", state0_enter_exec)
				{
				//objid
				my_objid = op_id_self ();
				my_node_id = op_topo_parent (my_objid); //parent process
				Objid layer_id;
				//Objid layer_id = op_topo_parent (my_node_id); //middle layer
				//Objid node_id = op_topo_parent (layer_id); //node
				
				int layer_num = op_topo_child_count (my_node_id, OPC_OBJTYPE_PROC);
				char layer_name[32] = {0};
				for (i = 0; i < layer_num; i++){
					layer_id = op_topo_child (my_node_id, OPC_OBJTYPE_PROC, i);
					op_ima_obj_attr_get (layer_id, "name", &layer_name);
					if ( !strcmp(layer_name, "phd_app") ){
						break;
					}
					//printf("%s \n",layer_name);
				}
				
				
				
				op_ima_obj_attr_get (my_node_id, "name", &name);
				self_ip_addr = icdtn_get_ip_address_from_name(name);
				
				if (self_ip_addr == 1)
					op_ima_obj_attr_get(layer_id,"int_rate",	&con_gen_rate);
				printf("int rate = %f  ", con_gen_rate);
				//con_gen_time = 100.0;
				
				op_ima_obj_attr_get_objid (my_node_id, "CCN",&protocol_compound);
				oid = op_topo_child (protocol_compound, OPC_OBJTYPE_GENERIC, 0);
				op_ima_obj_attr_get(oid,"cs_total_space",	&cs_total_space);
				op_ima_obj_attr_get(oid,"cs_total_size",	&cs_total_size);
				op_ima_obj_attr_get(oid,"hop_lim",			&hop_lim);
				op_ima_obj_attr_get(oid,"fib_expir_time",	&fib_expir_time);
				op_ima_obj_attr_get(oid,"pit_expir_time",	&pit_expir_time);
				op_ima_obj_attr_get(oid,"cs_expir_time",	&cs_expir_time);
				op_ima_obj_attr_get(oid,"hello_interval",	&hello_interval);
				op_ima_obj_attr_get(oid,"allow_loss",		&allow_loss);
				op_ima_obj_attr_get(oid,"producer",			&prod_f);
				op_ima_obj_attr_get(oid,"producer_content",	&prod_num);
				op_ima_obj_attr_get(oid,"prefetching",		&pref_f);
				op_ima_obj_attr_get(oid,"oneCP",			&OCP_f);
				/*
				printf("cs_total_space %d\n",cs_total_space);
				printf("cs_total_size %d\n",cs_total_size);
				printf("hop_lim %d\n",hop_lim);
				printf("fib_expir_time %f\n",fib_expir_time);
				printf("pit_expir_time %f\n",pit_expir_time);
				printf("cs_expir_time %f\n",cs_expir_time);
				printf("hello_interval %f\n",hello_interval);
				printf("allow_loss %f\n",allow_loss);
				printf("producer = %d\n",prod_f);
				printf("produce num = %d\n",prod_num);
				//*/
				
				
				printf("before pref_f = %d, OCP_f = %d\n",pref_f, OCP_f);
				
				if (OCP_f == 1)
					pref_f = (prod_f == 1 && pref_f == 1);
				else
					pref_f = (pref_f == 1);
				printf("node %d, after pref_f = %d, OCP_f = %d\n", self_ip_addr, pref_f, OCP_f);
				
				//neighbor
				neighbor_l = op_prg_list_create();
				hello_seq = 0; 
				
				//content storage list
				cs_list = op_prg_list_create();
				
				pit_list = op_prg_list_create();
				fib_list = op_prg_list_create();
				pit_ht 	 = prg_bin_hash_table_create(10,2);
				
				//prefetching record
				pro_rec = OPC_NIL;
				
				
				if ( prod_f == 1 ){
					if ( contentNum == OPC_NIL ){
						printf("node %d allocate %d space for contentNum\n",self_ip_addr, TOT_CON);
						contentNum = (int*)op_prg_mem_alloc(TOT_CON*sizeof(int));
					}
					
					op_intrpt_schedule_call (op_sim_time(), 0, icdtn_con_generate_cb, OPC_NIL);
					
					//for (i=0; i< TOT_CON; i++){
					//	icdtn_cs_t_add (i, op_pk_create(4000 + (int)op_dist_uniform(45000)), 0.0 );
					//}
					
					if ( conInitLf == OPC_NIL ){
						printf("node %d allocate %d space for content init life\n",self_ip_addr, TOT_CON);
						conInitLf = (double*)op_prg_mem_alloc(TOT_CON*sizeof(double));
					}
					if ( reqInitLf == OPC_NIL ){
						printf("node %d allocate %d space for req init life\n",self_ip_addr, TOT_CON);
						reqInitLf = (double*)op_prg_mem_alloc(TOT_CON*sizeof(double));
					}
					
				}
				
				if ( pref_f == 1){
					printf("node %d allocate %d space for rec\n",self_ip_addr, TOT_CON);
					pro_rec = (int*)op_prg_mem_alloc(TOT_CON*sizeof(int));
					memset(pro_rec, 0, TOT_CON*sizeof(int));
					
					//for (i=0; i< TOT_CON; i++){
					//	pro_rec[i] = 0;
					//}
				}
				
				//stat
				stat_link_num = op_stat_reg ("mobility.link number", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
				
				//schedule
				op_intrpt_schedule_call (OPC_INTRPT_SCHED_CALL_ENDSIM,0,icdtn_sim_end_cb,OPC_NIL);
				op_intrpt_schedule_call (op_sim_time()+SAMPLE_VAL,-1,icdtn_con_num_cb,OPC_NIL);
				op_intrpt_schedule_call (op_sim_time()+SAMPLE_VAL,-1,icdtn_buff_stat_cb,OPC_NIL);
				op_intrpt_schedule_call (op_sim_time()+SAMPLE_VAL,-1,icdtn_buff_age_stat_cb,OPC_NIL);
				
				//printf("prepare send hello\n");
				op_intrpt_schedule_self (op_sim_time(), HELLO_INTRPT_CODE);
				
				
				//op_sim_end("ini finish","","","");
				}
				FSM_PROFILE_SECTION_OUT (state0_enter_exec)

			/** state (init) exit executives **/
			FSM_STATE_EXIT_FORCED (0, "init", "ICbundle [init exit execs]")


			/** state (init) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "init", "idle", "tr_0", "ICbundle [init -> idle : default / ]")
				/*---------------------------------------------------------*/



			/** state (idle) enter executives **/
			FSM_STATE_ENTER_UNFORCED (1, "idle", state1_enter_exec, "ICbundle [idle enter execs]")

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (3,"ICbundle")


			/** state (idle) exit executives **/
			FSM_STATE_EXIT_UNFORCED (1, "idle", "ICbundle [idle exit execs]")
				FSM_PROFILE_SECTION_IN ("ICbundle [idle exit execs]", state1_exit_exec)
				{
				intrpt_type=op_intrpt_type();
				
				if(intrpt_type == OPC_INTRPT_STRM){
					intrpt_stream = op_intrpt_strm();
				}
				else if (intrpt_type == OPC_INTRPT_SELF){
					intrpt_code = op_intrpt_code();
					
				}
				
				
				
				}
				FSM_PROFILE_SECTION_OUT (state1_exit_exec)


			/** state (idle) transition processing **/
			FSM_PROFILE_SECTION_IN ("ICbundle [idle trans conditions]", state1_trans_conds)
			FSM_INIT_COND (DATA_FROM_APP)
			FSM_TEST_COND (DATA_FROM_IP)
			FSM_TEST_COND (HELLO_INTRPT)
			FSM_DFLT_COND
			FSM_TEST_LOGIC ("idle")
			FSM_PROFILE_SECTION_OUT (state1_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 2, state2_enter_exec, ;, "DATA_FROM_APP", "", "idle", "DATA_FROM_APP", "tr_2", "ICbundle [idle -> DATA_FROM_APP : DATA_FROM_APP / ]")
				FSM_CASE_TRANSIT (1, 3, state3_enter_exec, ;, "DATA_FROM_IP", "", "idle", "DATA_FROM_IP", "tr_3", "ICbundle [idle -> DATA_FROM_IP : DATA_FROM_IP / ]")
				FSM_CASE_TRANSIT (2, 4, state4_enter_exec, ;, "HELLO_INTRPT", "", "idle", "register", "tr_5", "ICbundle [idle -> register : HELLO_INTRPT / ]")
				FSM_CASE_TRANSIT (3, 1, state1_enter_exec, ;, "default", "", "idle", "idle", "tr_14", "ICbundle [idle -> idle : default / ]")
				}
				/*---------------------------------------------------------*/



			/** state (DATA_FROM_APP) enter executives **/
			FSM_STATE_ENTER_FORCED (2, "DATA_FROM_APP", state2_enter_exec, "ICbundle [DATA_FROM_APP enter execs]")
				FSM_PROFILE_SECTION_IN ("ICbundle [DATA_FROM_APP enter execs]", state2_enter_exec)
				{
				pk_from_app = op_pk_get (UPP_INPUT_STRM);
				op_pk_nfd_access (pk_from_app, "type", &type );
				
				if (type == DATA_APP_INT){
				//	op_intrpt_schedule_self (op_sim_time() , REQ_HANDLE_CODE);
				
					op_pk_nfd_access(pk_from_app, "name", &content_name);
					op_pk_destroy(pk_from_app);
				
					if (content_name >= TOT_CON)
						op_sim_end("Not enough content!","","","");
					
					cs_size  = op_prg_list_size(cs_list);
					pit_size = op_prg_list_size(pit_list);
				
					for (i = 0; i < cs_size; i++){
						cs_temp_t = op_prg_list_access(cs_list, i);
						//--------------------------if content found
						if (cs_temp_t->content_name == content_name){
							//----------------------setup pkt header
							pk_from_mac = op_pk_create_fmt ("ccn_app_data");
							op_pk_nfd_set	 (pk_from_mac, "type", DATA_APP_CON);
							op_pk_nfd_set	 (pk_from_mac, "name", content_name);
							op_pk_nfd_set_pkt(pk_from_mac, "payload", op_pk_copy(cs_temp_t->content_pk) );
							op_pk_nfd_set	 (pk_from_mac, "src", self_ip_addr);
				
							op_pk_send		 (pk_from_mac, UPP_OUTPUT_STRM);
							
							//two producers case havn't considered
							if ( reqInitLf[content_name] == 0.0)
									reqInitLf[content_name] = op_sim_time();
							op_intrpt_schedule_call (op_sim_time()+SAMPLE_VAL,content_name,icdtn_con_num_cb,OPC_NIL);
				
							
							break;
						}
					}
					
					//if content not found
					if (i == cs_size ){
						
						pit_temp = prg_bin_hash_table_item_get(pit_ht,&content_name);
						if (pit_temp == PRGC_NIL ){
							//if ( conInitLf[content_name] == 0.0 || ( conInitLf[content_name] + CS_EXPIR_TIME > op_sim_time ()) ){
							//12,23 updated
							//this condition is for two producers case
							if ( reqInitLf[content_name] == 0.0 || ( conInitLf[content_name] + CS_EXPIR_TIME > op_sim_time ()) ){ 
								if ( reqInitLf[content_name] == 0.0)
									reqInitLf[content_name] = op_sim_time();
								printf("node %d get interest %d from app, reqInitLf %f, conInitLf %f\n",
									self_ip_addr, content_name, reqInitLf[content_name], conInitLf[content_name]);
								icdtn_pit_add(content_name, self_ip_addr, op_sim_time());
								op_intrpt_schedule_call (op_sim_time(),content_name,icdtn_con_num_cb,OPC_NIL);
							}
							else
								printf("node %d get expired interest %d from app\n",self_ip_addr, content_name);
								
						}
						//if found in PIT, update pit and discard req
						else if (pit_temp->app == OPC_TRUE){
							//op_sim_end("data from app","pit_temp_t->app == OPC_TRUE","","");
							printf("node %d get duplicate PIT!\n", self_ip_addr);
						}
				
				//3.8 updated		
				/*********************************************************************************
						pit_temp = prg_bin_hash_table_item_get(pit_ht,&content_name);
						
						if (pit_temp != PRGC_NIL ){
							if ( pit_temp->app == OPC_TRUE){
								//op_sim_end("data from app","pit_temp_t->app == OPC_TRUE","","");
								printf("node %d get duplicate PIT!\n", self_ip_addr);
							}
							else {
								;//to be implemented
								//if found in PIT, update pit and discard req
							}
						}
						else {//(pit_temp == PRGC_NIL )
						
							//for statistic
							if ( reqInitLf[content_name] == 0.0 ){ 
								reqInitLf[content_name] = op_sim_time();
								op_intrpt_schedule_call (op_sim_time(),content_name,icdtn_con_num_cb,OPC_NIL);
							}
							else
								printf("node %d get expired interest %d from app\n",self_ip_addr, content_name);
				
							
							//check cs whether have matched content
							for (i = 0; i < cs_size; i++){
								cs_temp_t = op_prg_list_access(cs_list, i);
								//--------------------------if content found
								if (cs_temp_t->content_name == content_name){
									//----------------------setup pkt header
									pk_from_mac = op_pk_create_fmt ("ccn_app_data");
									op_pk_nfd_set	 (pk_from_mac, "type", DATA_APP_CON);
									op_pk_nfd_set	 (pk_from_mac, "name", content_name);
									op_pk_nfd_set_pkt(pk_from_mac, "payload", op_pk_copy(cs_temp_t->content_pk) );
									op_pk_nfd_set	 (pk_from_mac, "src", self_ip_addr);
				
									op_pk_send		 (pk_from_mac, UPP_OUTPUT_STRM);
							
									//two producers case havn't considered
									if ( reqInitLf[content_name] == 0.0)
										reqInitLf[content_name] = op_sim_time();
									op_intrpt_schedule_call (op_sim_time()+SAMPLE_VAL,content_name,icdtn_con_num_cb,OPC_NIL);
				
									break;
								}
							}
							
							if (i == cs_size ){
								printf("node %d get interest %d from app, reqInitLf %f, conInitLf %f\n",
									self_ip_addr, content_name, reqInitLf[content_name], conInitLf[content_name]);
								icdtn_pit_add(content_name, self_ip_addr, op_sim_time());
							}
						}		
				//*******************************************************************************/
						
				/*********************************************************************************************
						for (j = 0; j < pit_size; j++){
							//if found in PIT, update pit and discard req
							pit_temp_t = op_prg_list_access(pit_list, j);
							
							//search by content name sub list
							if (pit_temp_t->content_name == content_name){
							
								addr_list_size = op_prg_list_size(pit_temp_t->addr_l);
								for (k = 0; k < addr_list_size; k++){ 
									addr_temp_t = op_prg_list_access(pit_temp_t->addr_l, k);
									
						//*********************************update hop count*********************************
									if (addr_temp_t->addr == self_ip_addr){
										//update pending interest table
										//printf("node %d update int %d\n",self_ip_addr, content_name);
										op_ev_cancel_if_pending(addr_temp_t->expire);
										addr_temp_t->expire = op_intrpt_schedule_call
											(op_sim_time()+PIT_EXPIR_TIME, PIT_TYPE, 
											icdtn_addr_t_delete_cb, addr_temp_t );
								
										break; //discard req
									}	
								}
								
								//addr not found
								if (k == addr_list_size){
									icdtn_addr_add(self_ip_addr, pit_temp_t, PIT_TYPE, op_sim_time());	
								}	
						
								break;
							}
						}
						//if PI with content name is not found, add new PI and forward it
						if (j == pit_size){
							icdtn_pit_add(content_name, self_ip_addr, op_sim_time());
						}// end if (j == pit_size)
				//***********************************************************************************/
				
						
						
						
					}//end if (i == cs_size)
				}//end if (type == DATA_APP_INT)
				}
				FSM_PROFILE_SECTION_OUT (state2_enter_exec)

			/** state (DATA_FROM_APP) exit executives **/
			FSM_STATE_EXIT_FORCED (2, "DATA_FROM_APP", "ICbundle [DATA_FROM_APP exit execs]")


			/** state (DATA_FROM_APP) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "DATA_FROM_APP", "idle", "tr_1", "ICbundle [DATA_FROM_APP -> idle : default / ]")
				/*---------------------------------------------------------*/



			/** state (DATA_FROM_IP) enter executives **/
			FSM_STATE_ENTER_FORCED (3, "DATA_FROM_IP", state3_enter_exec, "ICbundle [DATA_FROM_IP enter execs]")
				FSM_PROFILE_SECTION_IN ("ICbundle [DATA_FROM_IP enter execs]", state3_enter_exec)
				{
				//pk_from_mac = op_pk_get(LOW_INPUT_STRM);
				//op_pk_print(p_bundle);
				if (pending_pk != OPC_NIL){
					op_pk_print(pending_pk);
				}
				pending_pk = op_pk_get(LOW_INPUT_STRM);
				op_pk_nfd_access(pending_pk , "pk_type", &type);
				//pending_pk = op_pk_copy(pk_from_mac);
				//op_pk_destroy(pk_from_mac);
				
				if (type == HELLO_TYPE){
					pending_pk = icdtn_hello_handle(pending_pk);
				}
				else if (type == CONTENT_TYPE){
					pending_pk = icdtn_data_handle(pending_pk);
					//op_intrpt_schedule_self(op_sim_time(),DATA_HANDLE_CODE);
				}
				else if (type == REQ_TYPE){
					pending_pk = icdtn_req_handle(pending_pk);
					//op_intrpt_schedule_self(op_sim_time(), REQ_HANDLE_CODE);
				}
				}
				FSM_PROFILE_SECTION_OUT (state3_enter_exec)

			/** state (DATA_FROM_IP) exit executives **/
			FSM_STATE_EXIT_FORCED (3, "DATA_FROM_IP", "ICbundle [DATA_FROM_IP exit execs]")


			/** state (DATA_FROM_IP) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "DATA_FROM_IP", "idle", "tr_4", "ICbundle [DATA_FROM_IP -> idle : default / ]")
				/*---------------------------------------------------------*/



			/** state (register) enter executives **/
			FSM_STATE_ENTER_FORCED (4, "register", state4_enter_exec, "ICbundle [register enter execs]")
				FSM_PROFILE_SECTION_IN ("ICbundle [register enter execs]", state4_enter_exec)
				{
				Packet* hello_pkt = op_pk_create_fmt("ICN_hello");
				op_pk_nfd_set (hello_pkt,"pk_type",HELLO_TYPE);
				op_pk_nfd_set (hello_pkt,"src",self_ip_addr);
				op_pk_nfd_set (hello_pkt,"dest",IP_BROADCAST_ADDR);//yang 2.1
				op_pk_nfd_set (hello_pkt,"seq_no",hello_seq);
				//op_pk_print (hello_pkt);
				
				hello_seq++;
				
				op_pk_send(hello_pkt, LOW_OUTPUT_STRM);
				
				op_intrpt_schedule_self (op_sim_time() + HELLO_INTERVAL +op_dist_uniform(0.1), HELLO_INTRPT_CODE);
				
				//stat
				i = op_prg_list_size (neighbor_l);
				op_stat_write(stat_link_num, (double)i);
				}
				FSM_PROFILE_SECTION_OUT (state4_enter_exec)

			/** state (register) exit executives **/
			FSM_STATE_EXIT_FORCED (4, "register", "ICbundle [register exit execs]")


			/** state (register) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "register", "idle", "tr_6", "ICbundle [register -> idle : default / ]")
				/*---------------------------------------------------------*/



			}


		FSM_EXIT (0,"ICbundle")
		}
	}




void
_op_ICbundle_diag (OP_SIM_CONTEXT_ARG_OPT)
	{
	/* No Diagnostic Block */
	}




void
_op_ICbundle_terminate (OP_SIM_CONTEXT_ARG_OPT)
	{

	FIN_MT (_op_ICbundle_terminate ())


	/* No Termination Block */

	Vos_Poolmem_Dealloc (op_sv_ptr);

	FOUT
	}


/* Undefine shortcuts to state variables to avoid */
/* syntax error in direct access to fields of */
/* local variable prs_ptr in _op_ICbundle_svar function. */
#undef name
#undef expire_time
#undef retrans_time
#undef content_seq
#undef cs_total_size
#undef cs_total_space
#undef hello_seq
#undef hop_lim
#undef self_ip_addr
#undef cs_list
#undef fib_list
#undef neighbor_l
#undef pit_list
#undef my_node_id
#undef my_objid
#undef cs_remain_space
#undef pending_pk
#undef stat_link_num
#undef fib_expir_time
#undef pit_expir_time
#undef cs_expir_time
#undef hello_interval
#undef allow_loss
#undef prod_f
#undef pit_ht
#undef prod_num
#undef pref_f
#undef pro_rec
#undef OCP_f

#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE

#define FIN_PREAMBLE_DEC
#define FIN_PREAMBLE_CODE

VosT_Obtype
_op_ICbundle_init (int * init_block_ptr)
	{
	VosT_Obtype obtype = OPC_NIL;
	FIN_MT (_op_ICbundle_init (init_block_ptr))

	obtype = Vos_Define_Object_Prstate ("proc state vars (ICbundle)",
		sizeof (ICbundle_state));
	*init_block_ptr = 0;

	FRET (obtype)
	}

VosT_Address
_op_ICbundle_alloc (VosT_Obtype obtype, int init_block)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	ICbundle_state * ptr;
	FIN_MT (_op_ICbundle_alloc (obtype))

	ptr = (ICbundle_state *)Vos_Alloc_Object (obtype);
	if (ptr != OPC_NIL)
		{
		ptr->_op_current_block = init_block;
#if defined (OPD_ALLOW_ODB)
		ptr->_op_current_state = "ICbundle [init enter execs]";
#endif
		}
	FRET ((VosT_Address)ptr)
	}



void
_op_ICbundle_svar (void * gen_ptr, const char * var_name, void ** var_p_ptr)
	{
	ICbundle_state		*prs_ptr;

	FIN_MT (_op_ICbundle_svar (gen_ptr, var_name, var_p_ptr))

	if (var_name == OPC_NIL)
		{
		*var_p_ptr = (void *)OPC_NIL;
		FOUT
		}
	prs_ptr = (ICbundle_state *)gen_ptr;

	if (strcmp ("name" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->name);
		FOUT
		}
	if (strcmp ("expire_time" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->expire_time);
		FOUT
		}
	if (strcmp ("retrans_time" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->retrans_time);
		FOUT
		}
	if (strcmp ("content_seq" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->content_seq);
		FOUT
		}
	if (strcmp ("cs_total_size" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->cs_total_size);
		FOUT
		}
	if (strcmp ("cs_total_space" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->cs_total_space);
		FOUT
		}
	if (strcmp ("hello_seq" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->hello_seq);
		FOUT
		}
	if (strcmp ("hop_lim" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->hop_lim);
		FOUT
		}
	if (strcmp ("self_ip_addr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->self_ip_addr);
		FOUT
		}
	if (strcmp ("cs_list" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->cs_list);
		FOUT
		}
	if (strcmp ("fib_list" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->fib_list);
		FOUT
		}
	if (strcmp ("neighbor_l" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->neighbor_l);
		FOUT
		}
	if (strcmp ("pit_list" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->pit_list);
		FOUT
		}
	if (strcmp ("my_node_id" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->my_node_id);
		FOUT
		}
	if (strcmp ("my_objid" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->my_objid);
		FOUT
		}
	if (strcmp ("cs_remain_space" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->cs_remain_space);
		FOUT
		}
	if (strcmp ("pending_pk" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->pending_pk);
		FOUT
		}
	if (strcmp ("stat_link_num" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->stat_link_num);
		FOUT
		}
	if (strcmp ("fib_expir_time" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->fib_expir_time);
		FOUT
		}
	if (strcmp ("pit_expir_time" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->pit_expir_time);
		FOUT
		}
	if (strcmp ("cs_expir_time" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->cs_expir_time);
		FOUT
		}
	if (strcmp ("hello_interval" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->hello_interval);
		FOUT
		}
	if (strcmp ("allow_loss" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->allow_loss);
		FOUT
		}
	if (strcmp ("prod_f" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->prod_f);
		FOUT
		}
	if (strcmp ("pit_ht" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->pit_ht);
		FOUT
		}
	if (strcmp ("prod_num" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->prod_num);
		FOUT
		}
	if (strcmp ("pref_f" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->pref_f);
		FOUT
		}
	if (strcmp ("pro_rec" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->pro_rec);
		FOUT
		}
	if (strcmp ("OCP_f" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->OCP_f);
		FOUT
		}
	*var_p_ptr = (void *)OPC_NIL;

	FOUT
	}

